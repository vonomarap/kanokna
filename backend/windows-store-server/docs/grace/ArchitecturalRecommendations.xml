<?xml version="1.0" encoding="UTF-8"?>
<!--
  GRACE Artifact: ArchitecturalRecommendations.xml
  Purpose: Supplementary guidance for implementation quality and operational readiness
  Version: 1.0.0
  Created: 2025-12-30
-->
<ArchitecturalRecommendations version="1.0.0">

  <!-- ═══════════════════════════════════════════════════════════════════════════
       RISK MITIGATION
       ═══════════════════════════════════════════════════════════════════════════ -->
  <RiskMitigation>
    <Risk id="RISK-002" severity="HIGH">
      <Title>YooKassa Integration Complexity</Title>
      <Description>Russian payment regulations (54-FZ) require fiscal receipts</Description>
      <Mitigation>
        <Action>Create YooKassa sandbox account early in Wave 0</Action>
        <Action>Study 54-FZ receipt requirements before Wave 2</Action>
        <Action>Implement receipt generation as separate adapter (swappable)</Action>
        <Action>Add integration tests against YooKassa sandbox</Action>
      </Mitigation>
    </Risk>

    <Risk id="RISK-004" severity="MEDIUM">
      <Title>Event Ordering and Idempotency</Title>
      <Description>Kafka consumers may receive duplicate or out-of-order events</Description>
      <Mitigation>
        <Action>Include eventId (UUID) in all domain events</Action>
        <Action>Store processed eventIds for deduplication</Action>
        <Action>Design handlers to be idempotent</Action>
        <Action>Use Kafka consumer group offsets correctly</Action>
      </Mitigation>
    </Risk>

    <Risk id="RISK-005" severity="LOW">
      <Title>Elasticsearch Version Drift</Title>
      <Description>ES 8.x has breaking changes from 7.x</Description>
      <Mitigation>
        <Action>Pin Elasticsearch client version explicitly</Action>
        <Action>Use Spring Data Elasticsearch abstraction</Action>
        <Action>Document index mapping strategy</Action>
      </Mitigation>
    </Risk>
  </RiskMitigation>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       RECOMMENDED PATTERNS
       ═══════════════════════════════════════════════════════════════════════════ -->
  <RecommendedPatterns>
    <Pattern id="PAT-001" name="Result Pattern for Domain Operations">
      <Description>Use Result/Either instead of exceptions for expected failures</Description>
      <Rationale>
        Cleaner error handling, forces caller to handle failures,
        better for functional composition
      </Rationale>
      <Example><![CDATA[
public sealed interface Result<T> {
    record Success<T>(T value) implements Result<T> {}
    record Failure<T>(DomainError error) implements Result<T> {}

    default T getOrThrow() {
        return switch (this) {
            case Success<T> s -> s.value();
            case Failure<T> f -> throw new DomainException(f.error());
        };
    }
}

// Usage in domain service
public Result<ValidationResult> validateConfiguration(ConfigurationSelection selection) {
    if (selection.dimensions().width() < MIN_WIDTH) {
        return new Result.Failure<>(DomainError.DIMENSION_TOO_SMALL);
    }
    // ... validation logic
    return new Result.Success<>(validationResult);
}
      ]]></Example>
      <Location>shared-kernel module</Location>
    </Pattern>

    <Pattern id="PAT-002" name="Specification Pattern for Rules">
      <Description>Encapsulate business rules as composable specifications</Description>
      <Rationale>
        Rules become testable units, can be combined with AND/OR,
        supports dynamic rule loading
      </Rationale>
      <Example><![CDATA[
public interface ConfigurationRule {
    ValidationMessage validate(ConfigurationSelection selection);
    boolean appliesTo(ProductType type);
}

public class DimensionConstraintRule implements ConfigurationRule {
    @Override
    public ValidationMessage validate(ConfigurationSelection selection) {
        // BA-CFG-VAL-01: Check dimension constraints
        if (selection.dimensions().area() > MAX_AREA) {
            return ValidationMessage.error("ERR-CFG-DIM-001", "Area exceeds maximum");
        }
        return ValidationMessage.ok();
    }
}

// Composite rule evaluation
public class ConfigurationRuleEngine {
    private final List<ConfigurationRule> rules;

    public ValidationResult evaluate(ConfigurationSelection selection) {
        return rules.stream()
            .filter(r -> r.appliesTo(selection.productType()))
            .map(r -> r.validate(selection))
            .collect(ValidationResult.collector());
    }
}
      ]]></Example>
      <Location>catalog-configuration-service domain layer</Location>
    </Pattern>

    <Pattern id="PAT-003" name="Outbox Pattern with Polling">
      <Description>Reliable event publishing via transactional outbox</Description>
      <Rationale>
        Guarantees at-least-once delivery, survives service restarts,
        maintains transactional consistency
      </Rationale>
      <Example><![CDATA[
-- Outbox table
CREATE TABLE outbox_events (
    id UUID PRIMARY KEY,
    aggregate_type VARCHAR(255) NOT NULL,
    aggregate_id VARCHAR(255) NOT NULL,
    event_type VARCHAR(255) NOT NULL,
    payload BYTEA NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    published_at TIMESTAMP NULL
);

CREATE INDEX idx_outbox_unpublished ON outbox_events(created_at)
    WHERE published_at IS NULL;

// Outbox publisher (in same transaction as domain operation)
@Transactional
public void placeOrder(PlaceOrderCommand cmd) {
    Order order = orderRepository.save(createOrder(cmd));
    outboxRepository.save(new OutboxEvent(
        "Order", order.id(),
        "OrderCreatedEvent", serialize(order.toEvent())
    ));
}

// Outbox relay (separate scheduled job)
@Scheduled(fixedDelay = 1000)
public void publishPendingEvents() {
    List<OutboxEvent> events = outboxRepository.findUnpublished(100);
    for (OutboxEvent event : events) {
        kafkaTemplate.send(event.topic(), event.payload());
        event.markPublished();
        outboxRepository.save(event);
    }
}
      ]]></Example>
      <Location>Each service with domain events</Location>
    </Pattern>

    <Pattern id="PAT-004" name="Correlation Context Propagation">
      <Description>Propagate correlation ID across all service calls</Description>
      <Rationale>
        Enables distributed tracing, log correlation, debugging
      </Rationale>
      <Example><![CDATA[
// Gateway filter sets correlation ID
public class CorrelationFilter implements GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String correlationId = exchange.getRequest().getHeaders()
            .getFirst("X-Correlation-ID");
        if (correlationId == null) {
            correlationId = UUID.randomUUID().toString();
        }
        MDC.put("correlationId", correlationId);
        return chain.filter(exchange.mutate()
            .request(r -> r.header("X-Correlation-ID", correlationId))
            .build());
    }
}

// gRPC interceptor propagates correlation ID
public class CorrelationClientInterceptor implements ClientInterceptor {
    @Override
    public <Q, R> ClientCall<Q, R> interceptCall(
            MethodDescriptor<Q, R> method, CallOptions options, Channel next) {
        return new ForwardingClientCall.SimpleForwardingClientCall<>(
                next.newCall(method, options)) {
            @Override
            public void start(Listener<R> listener, Metadata headers) {
                String correlationId = MDC.get("correlationId");
                if (correlationId != null) {
                    headers.put(CORRELATION_ID_KEY, correlationId);
                }
                super.start(listener, headers);
            }
        };
    }
}
      ]]></Example>
      <Location>gateway, all services</Location>
    </Pattern>

    <Pattern id="PAT-005" name="Circuit Breaker with Fallback">
      <Description>Protect services from cascading failures</Description>
      <Rationale>
        Prevents resource exhaustion, enables graceful degradation
      </Rationale>
      <Example><![CDATA[
// Resilience4j configuration
resilience4j:
  circuitbreaker:
    instances:
      pricingService:
        slidingWindowSize: 10
        failureRateThreshold: 50
        waitDurationInOpenState: 10s
        permittedNumberOfCallsInHalfOpenState: 3
  retry:
    instances:
      pricingService:
        maxAttempts: 3
        waitDuration: 500ms
        retryExceptions:
          - io.grpc.StatusRuntimeException

// Service with circuit breaker
@Service
public class PricingGrpcClient implements PricingPort {

    @CircuitBreaker(name = "pricingService", fallbackMethod = "fallbackQuote")
    @Retry(name = "pricingService")
    public Quote getQuote(QuoteRequest request) {
        return pricingStub.calculateQuote(request);
    }

    private Quote fallbackQuote(QuoteRequest request, Exception e) {
        log.warn("Pricing service unavailable, returning cached quote", e);
        return quoteCache.getLastKnown(request.configurationId())
            .orElseThrow(() -> new ServiceUnavailableException("Pricing"));
    }
}
      ]]></Example>
      <Location>All gRPC clients</Location>
    </Pattern>
  </RecommendedPatterns>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       OBSERVABILITY STRATEGY
       ═══════════════════════════════════════════════════════════════════════════ -->
  <ObservabilityStrategy>
    <Logging>
      <Principle>Structured JSON logging for all services</Principle>
      <Principle>Include correlationId, service, block anchor in every log</Principle>
      <Principle>Log at INFO for business events, DEBUG for technical details</Principle>
      <Configuration><![CDATA[
# logback-spring.xml pattern
<pattern>
{
  "timestamp": "%d{ISO8601}",
  "level": "%level",
  "service": "${SERVICE_NAME}",
  "correlationId": "%X{correlationId}",
  "blockAnchor": "%X{blockAnchor}",
  "logger": "%logger{36}",
  "message": "%message",
  "exception": "%exception"
}
</pattern>
      ]]></Configuration>
      <StandardFields>
        <Field name="correlationId">Request trace ID</Field>
        <Field name="blockAnchor">Current code block (BA-XXX-XXX)</Field>
        <Field name="userId">Authenticated user ID</Field>
        <Field name="orderId">Order context when applicable</Field>
        <Field name="latencyMs">Operation duration</Field>
        <Field name="decision">Business decision made</Field>
      </StandardFields>
    </Logging>

    <Metrics>
      <Tool>Micrometer with Prometheus registry</Tool>
      <StandardMetrics>
        <Metric name="http_server_requests" type="timer">REST endpoint latency</Metric>
        <Metric name="grpc_server_calls" type="timer">gRPC method latency</Metric>
        <Metric name="db_query_duration" type="timer">Database query time</Metric>
        <Metric name="cache_hits/misses" type="counter">Redis cache effectiveness</Metric>
        <Metric name="circuit_breaker_state" type="gauge">Circuit breaker status</Metric>
        <Metric name="kafka_consumer_lag" type="gauge">Event processing lag</Metric>
      </StandardMetrics>
      <BusinessMetrics>
        <Metric name="orders_placed_total" type="counter">Orders created</Metric>
        <Metric name="orders_confirmed_total" type="counter">Payments successful</Metric>
        <Metric name="orders_failed_total" type="counter">Payment failures</Metric>
        <Metric name="configuration_validations_total" type="counter">Configs validated</Metric>
        <Metric name="quotes_calculated_total" type="counter">Price quotes</Metric>
        <Metric name="cart_abandonment_rate" type="gauge">Carts not converted</Metric>
      </BusinessMetrics>
    </Metrics>

    <Tracing>
      <Tool>OpenTelemetry with Jaeger/Zipkin backend</Tool>
      <Configuration><![CDATA[
# application.yml
management:
  tracing:
    sampling:
      probability: 1.0  # 100% in dev, reduce in prod
  otlp:
    tracing:
      endpoint: http://jaeger:4318/v1/traces
      ]]></Configuration>
      <SpanNaming>
        <Convention>HTTP: "HTTP {method} {path}"</Convention>
        <Convention>gRPC: "gRPC {service}/{method}"</Convention>
        <Convention>Kafka: "Kafka {topic} {operation}"</Convention>
        <Convention>DB: "DB {operation} {table}"</Convention>
      </SpanNaming>
    </Tracing>

    <Alerting>
      <Alert name="HighErrorRate" severity="critical">
        <Condition>error_rate > 5% for 5 minutes</Condition>
        <Action>Page on-call engineer</Action>
      </Alert>
      <Alert name="HighLatency" severity="warning">
        <Condition>p95_latency > 2s for 10 minutes</Condition>
        <Action>Slack notification</Action>
      </Alert>
      <Alert name="PaymentFailures" severity="critical">
        <Condition>payment_failures > 10 in 5 minutes</Condition>
        <Action>Page on-call + notify business</Action>
      </Alert>
      <Alert name="CircuitBreakerOpen" severity="warning">
        <Condition>circuit_breaker_state = OPEN</Condition>
        <Action>Slack notification</Action>
      </Alert>
      <Alert name="KafkaLagHigh" severity="warning">
        <Condition>consumer_lag > 10000 for 15 minutes</Condition>
        <Action>Slack notification</Action>
      </Alert>
    </Alerting>
  </ObservabilityStrategy>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       SECURITY HARDENING
       ═══════════════════════════════════════════════════════════════════════════ -->
  <SecurityHardening>
    <Authentication>
      <Recommendation>Use short-lived JWT tokens (15 min access, 7 day refresh)</Recommendation>
      <Recommendation>Validate token signature AND claims (iss, aud, exp)</Recommendation>
      <Recommendation>Implement token revocation via Redis blacklist</Recommendation>
      <Recommendation>Use PKCE for public clients (mobile, SPA)</Recommendation>
    </Authentication>

    <Authorization>
      <Recommendation>Implement RBAC with roles: CUSTOMER, INSTALLER, ADMIN, SYSTEM</Recommendation>
      <Recommendation>Use @PreAuthorize for method-level security</Recommendation>
      <Recommendation>Validate resource ownership (user can only access own orders)</Recommendation>
      <Recommendation>Audit all admin operations</Recommendation>
    </Authorization>

    <DataProtection>
      <Recommendation>Encrypt PII at rest (addresses, phone numbers)</Recommendation>
      <Recommendation>Never log sensitive data (passwords, card numbers, tokens)</Recommendation>
      <Recommendation>Use parameterized queries (JPA handles this)</Recommendation>
      <Recommendation>Implement field-level encryption for sensitive columns</Recommendation>
    </DataProtection>

    <APIProtection>
      <Recommendation>Rate limiting per client: 100 req/min authenticated, 20 req/min anonymous</Recommendation>
      <Recommendation>Request size limits: 1MB for API, 10MB for media uploads</Recommendation>
      <Recommendation>Input validation at controller boundary (@Valid)</Recommendation>
      <Recommendation>Output encoding to prevent XSS</Recommendation>
      <Recommendation>CORS restricted to known frontend origins</Recommendation>
    </APIProtection>

    <PaymentSecurity>
      <Recommendation>Never store card numbers - use YooKassa tokenization</Recommendation>
      <Recommendation>Verify webhook signatures cryptographically</Recommendation>
      <Recommendation>Implement amount validation before capture</Recommendation>
      <Recommendation>Log payment events without sensitive data</Recommendation>
      <Recommendation>PCI-DSS: ensure no card data in logs or database</Recommendation>
    </PaymentSecurity>

    <SecretManagement>
      <Recommendation>Store secrets in environment variables or vault</Recommendation>
      <Recommendation>Rotate API keys and credentials regularly</Recommendation>
      <Recommendation>Use Spring Cloud Config encryption for sensitive props</Recommendation>
      <Recommendation>Never commit secrets to git (.env in .gitignore)</Recommendation>
    </SecretManagement>
  </SecurityHardening>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       PERFORMANCE OPTIMIZATION
       ═══════════════════════════════════════════════════════════════════════════ -->
  <PerformanceOptimization>
    <DatabaseOptimization>
      <Recommendation>Add indexes for all foreign keys and query predicates</Recommendation>
      <Recommendation>Use database connection pooling (HikariCP defaults are good)</Recommendation>
      <Recommendation>Enable query logging in dev to catch N+1 problems</Recommendation>
      <Recommendation>Use projections for read-only queries</Recommendation>
      <Recommendation>Batch inserts/updates where possible</Recommendation>
      <Example><![CDATA[
-- Recommended indexes for orders table
CREATE INDEX idx_orders_customer_id ON orders(customer_id);
CREATE INDEX idx_orders_status ON orders(status) WHERE status NOT IN ('COMPLETED', 'CANCELLED');
CREATE INDEX idx_orders_created_at ON orders(created_at DESC);

-- Partial index for active orders only
CREATE INDEX idx_orders_active ON orders(customer_id, created_at)
    WHERE status NOT IN ('COMPLETED', 'CANCELLED');
      ]]></Example>
    </DatabaseOptimization>

    <CachingStrategy>
      <Layer name="Local Cache">
        <Tool>Caffeine</Tool>
        <Use>Static reference data (product types, materials list)</Use>
        <TTL>5 minutes</TTL>
      </Layer>
      <Layer name="Distributed Cache">
        <Tool>Redis</Tool>
        <Use>Price quotes, user sessions, idempotency keys</Use>
        <TTL>Varies by use case</TTL>
      </Layer>
      <Layer name="HTTP Cache">
        <Tool>Cache-Control headers</Tool>
        <Use>Product images, static assets</Use>
        <TTL>1 hour for images, 1 year for versioned assets</TTL>
      </Layer>
      <CacheKeys><![CDATA[
// Redis key patterns
quote:{configurationHash}          -> Quote JSON (TTL: 5 min)
idempotency:{idempotencyKey}       -> OrderId (TTL: 24 hours)
session:{sessionId}                -> Session data (TTL: 30 min)
cart:{cartId}                      -> Cart JSON (TTL: 7 days)
user:profile:{userId}              -> Profile JSON (TTL: 1 hour)
      ]]></CacheKeys>
    </CachingStrategy>

    <AsyncProcessing>
      <Recommendation>Use virtual threads for I/O-bound operations (Java 21+)</Recommendation>
      <Recommendation>Process non-critical operations asynchronously</Recommendation>
      <Recommendation>Use Kafka for event-driven workflows</Recommendation>
      <Example><![CDATA[
// Virtual thread executor for gRPC calls
@Bean
public ExecutorService grpcExecutor() {
    return Executors.newVirtualThreadPerTaskExecutor();
}

// Async notification sending
@Async
@EventListener
public void onOrderCreated(OrderCreatedEvent event) {
    notificationService.sendOrderConfirmation(event);
}
      ]]></Example>
    </AsyncProcessing>

    <GrpcOptimization>
      <Recommendation>Use streaming for large result sets</Recommendation>
      <Recommendation>Set appropriate deadlines (not infinite)</Recommendation>
      <Recommendation>Enable keepalive for long-lived connections</Recommendation>
      <Recommendation>Use compression for large payloads</Recommendation>
      <Configuration><![CDATA[
grpc:
  server:
    port: 9081
    enable-keep-alive: true
    keep-alive-time: 30s
    max-inbound-message-size: 4MB
  client:
    pricing-service:
      address: dns:///pricing-service:9082
      enable-keep-alive: true
      negotiation-type: PLAINTEXT  # TLS in production
      deadline: 5s
      ]]></Configuration>
    </GrpcOptimization>
  </PerformanceOptimization>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       DEVELOPER EXPERIENCE
       ═══════════════════════════════════════════════════════════════════════════ -->
  <DeveloperExperience>
    <LocalDevelopment>
      <Recommendation>Single command startup: docker-compose up -d</Recommendation>
      <Recommendation>Hot reload for rapid iteration</Recommendation>
      <Recommendation>Consistent dev/prod parity via containers</Recommendation>
      <Recommendation>Pre-seeded test data for common scenarios</Recommendation>
      <Scripts>
        <Script name="scripts/dev-setup.sh">Initialize local environment</Script>
        <Script name="scripts/seed-data.sh">Load test data</Script>
        <Script name="scripts/reset-db.sh">Clean database state</Script>
        <Script name="scripts/logs.sh">Tail all service logs</Script>
      </Scripts>
    </LocalDevelopment>

    <Debugging>
      <Recommendation>Enable gRPC reflection for grpcurl/grpcui</Recommendation>
      <Recommendation>Expose actuator endpoints in dev profile</Recommendation>
      <Recommendation>Include request/response logging at DEBUG level</Recommendation>
      <Tools>
        <Tool name="grpcui">Web UI for gRPC service exploration</Tool>
        <Tool name="kafkacat">CLI for Kafka topic inspection</Tool>
        <Tool name="pgAdmin">PostgreSQL administration</Tool>
        <Tool name="RedisInsight">Redis data browser</Tool>
        <Tool name="Kibana">Elasticsearch/log exploration</Tool>
      </Tools>
    </Debugging>

    <Testing>
      <Recommendation>Use Testcontainers for integration tests</Recommendation>
      <Recommendation>Create test fixtures for common scenarios</Recommendation>
      <Recommendation>Mock external services (YooKassa) in tests</Recommendation>
      <TestProfiles>
        <Profile name="unit">No containers, fast execution</Profile>
        <Profile name="integration">Testcontainers, real dependencies</Profile>
        <Profile name="contract">API contract validation</Profile>
        <Profile name="e2e">Full stack with Docker Compose</Profile>
      </TestProfiles>
    </Testing>

    <Documentation>
      <Recommendation>Auto-generate API docs from OpenAPI/Proto</Recommendation>
      <Recommendation>README.md in each service with setup instructions</Recommendation>
      <Recommendation>Architecture Decision Records (ADRs) for key decisions</Recommendation>
      <Recommendation>Runbook for common operational tasks</Recommendation>
    </Documentation>
  </DeveloperExperience>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       IMMEDIATE ACTIONS (Before Wave 0)
       ═══════════════════════════════════════════════════════════════════════════ -->
  <ImmediateActions>
    <Action id="IA-001" priority="CRITICAL">
      <Title>Downgrade Spring Boot to 3.3.x</Title>
      <Description>Spring Boot 4.0.0 does not exist yet. Update parent POM.</Description>
      <Steps>
        <Step>Change spring-boot.version to 3.3.7 in parent POM</Step>
        <Step>Change spring-cloud.version to 2023.0.4</Step>
        <Step>Verify all dependencies resolve</Step>
        <Step>Run mvn clean install to validate</Step>
      </Steps>
    </Action>

    <Action id="IA-002" priority="HIGH">
      <Title>Create YooKassa Sandbox Account</Title>
      <Description>Set up test environment for payment integration</Description>
      <Steps>
        <Step>Register at yookassa.ru</Step>
        <Step>Create test shop</Step>
        <Step>Note shop ID and secret key</Step>
        <Step>Store credentials in config-server (encrypted)</Step>
      </Steps>
    </Action>

    <Action id="IA-003" priority="HIGH">
      <Title>Set up Keycloak Realm</Title>
      <Description>Configure identity provider for local development</Description>
      <Steps>
        <Step>Create realm: kanokna</Step>
        <Step>Create clients: gateway, admin-ui</Step>
        <Step>Define roles: CUSTOMER, INSTALLER, ADMIN</Step>
        <Step>Create test users for each role</Step>
        <Step>Export realm config for Docker Compose init</Step>
      </Steps>
    </Action>

    <Action id="IA-004" priority="MEDIUM">
      <Title>Configure GitHub Repository</Title>
      <Description>Set up repository for CI/CD</Description>
      <Steps>
        <Step>Enable branch protection on main</Step>
        <Step>Require PR reviews before merge</Step>
        <Step>Add repository secrets for deployments</Step>
        <Step>Enable Dependabot for security updates</Step>
      </Steps>
    </Action>
  </ImmediateActions>

</ArchitecturalRecommendations>
