<?xml version="1.0" encoding="UTF-8"?>
<!--
  GRACE Coder Work Order: Security Scan Remediation
  Created: 2026-01-21T14:40:00+03:00
  CreatedBy: GRACE-COORDINATOR
  HandoffRef: Handoff-20260121-01-W1-SECURITY-SCAN-REMEDIATION
  ApprovalRef: approvals.log @ 2026-01-21T14:30:00+03:00
-->
<CODER_WORK_ORDER id="CWO-20260121-01" status="ISSUED">
  <Preconditions>
    <Item status="VERIFIED">Handoff exists: Handoff-20260121-01-W1-SECURITY-SCAN-REMEDIATION</Item>
    <Item status="VERIFIED">Valid approval exists in docs/grace/approvals.log</Item>
    <Item status="VERIFIED">BranchSpec BS-20260121-01-SECURITY-SCAN-REMEDIATION is included and must be followed verbatim</Item>
    <Item status="VERIFIED">All referenced artifact sections and contract IDs are provided</Item>
    <Item status="VERIFIED">No blocking PENDING_HUMAN/TBD decisions for in-scope implementation</Item>
    <Item>Human-readable code is mandatory: prefer clarity over cleverness</Item>
    <Item>Error handling must be domain-focused and consistent across the module</Item>
  </Preconditions>

  <Scope>
    <HandoffRef>Handoff-20260121-01-W1-SECURITY-SCAN-REMEDIATION</HandoffRef>
    <BranchSpecRef>BS-20260121-01</BranchSpecRef>
    <Services>
      <ServiceRef ref="DP-SVC-shared-kernel" note="Add OWASP Encoder + LogSanitizer"/>
      <ServiceRef ref="DP-SVC-pricing-service" note="Fix log injection"/>
      <ServiceRef ref="DP-SVC-account-service" note="Fix null deref, CSRF comment"/>
      <ServiceRef ref="DP-SVC-cart-service" note="Fix unread var, CSRF comment"/>
      <ServiceRef ref="DP-SVC-search-service" note="Fix switch/deprecated, CSRF comment"/>
      <ServiceRef ref="DP-SVC-catalog-configuration-service" note="Fix NFE, CSRF comment"/>
      <ServiceRef ref="DP-SVC-gateway" note="CSRF comment"/>
      <ServiceRef ref="DP-SVC-config-server" note="CSRF comment"/>
    </Services>
    <Decisions>
      <DecisionRef id="DEC-SEC-CSRF-STATELESS"/>
      <DecisionRef id="DEC-SEC-LOG-SANITIZATION"/>
      <DecisionRef id="DEC-SEC-CODEQL-EXCLUSIONS"/>
    </Decisions>
    <Contracts>
      <ModuleContractRef id="MC-shared-kernel-logging-LogSanitizer"/>
      <FunctionContractRef id="FC-logsanitizer-sanitize"/>
      <FunctionContractRef id="FC-logsanitizer-sanitizeMap"/>
      <TestCaseRef id="TC-LOG-SANITIZE-001"/>
      <TestCaseRef id="TC-LOG-SANITIZE-002"/>
      <TestCaseRef id="TC-LOG-SANITIZE-003"/>
      <TestCaseRef id="TC-LOG-SANITIZE-004"/>
    </Contracts>
  </Scope>

  <ImplementationRules>
    <Item>No new endpoints/events/services beyond the approved handoff scope</Item>
    <Item>Embed semantic contracts verbatim (IDs unchanged)</Item>
    <Item>Logs must follow canonical format and reference BA anchors</Item>
    <Item>Implement tests matching all referenced TC-* cases</Item>
    <Item>Respect hexagonal layering (domain free of Spring/JPA/etc.)</Item>
    <Item>No cross-service join logic introduced</Item>
    <Item>Use Technology.xml decisions only (no alternative stacks)</Item>
    <Item>OWASP Encoder is allowed in shared-kernel (not in banned frameworks list)</Item>
  </ImplementationRules>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       GIT EXECUTION (from BranchSpec BS-20260121-01)
       ═══════════════════════════════════════════════════════════════════════════ -->
  <GitExecution>
    <Step order="1">
      <Command>git checkout develop &amp;&amp; git pull origin develop</Command>
      <Purpose>Ensure develop is up to date</Purpose>
    </Step>
    <Step order="2">
      <Command>git checkout -b bugfix/W1-security-scan-remediation</Command>
      <Purpose>Create feature branch per BranchSpec</Purpose>
    </Step>
    <Step order="3">
      <Note>Implement all changes per FilePlan below</Note>
    </Step>
    <Step order="4">
      <Command>mvn clean verify</Command>
      <Purpose>Verify all tests pass</Purpose>
    </Step>
    <Step order="5">
      <Command>git add -A &amp;&amp; git commit -m "[W1-SECURITY-SCAN] Remediate GitHub CodeQL security alerts"</Command>
      <Purpose>Commit changes</Purpose>
    </Step>
    <Step order="6">
      <Command>git push -u origin bugfix/W1-security-scan-remediation</Command>
      <Purpose>Push to remote</Purpose>
    </Step>
    <Step order="7">
      <Command>gh pr create --base develop --title "[W1-SECURITY-SCAN] Remediate GitHub CodeQL security alerts" --body "..."</Command>
      <Purpose>Create PR per BranchSpec template</Purpose>
    </Step>
  </GitExecution>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       FILE PLAN
       ═══════════════════════════════════════════════════════════════════════════ -->
  <FilePlan>
    <!-- TG-1: HIGH SEVERITY - Log Injection Fix -->
    <FileGroup id="TG-1" name="Log Injection Fix (CRITICAL)">
      <File action="UPDATE" priority="1">
        <Path>shared/shared-kernel/pom.xml</Path>
        <Purpose>Add OWASP Encoder dependency</Purpose>
        <Change><![CDATA[
Add dependency in <dependencies> section:
<dependency>
  <groupId>org.owasp.encoder</groupId>
  <artifactId>encoder</artifactId>
  <version>1.2.3</version>
</dependency>
        ]]></Change>
      </File>

      <File action="CREATE" priority="2">
        <Path>shared/shared-kernel/src/main/java/com/kanokna/shared/logging/LogSanitizer.java</Path>
        <Purpose>Log sanitization utility per MC-shared-kernel-logging-LogSanitizer</Purpose>
        <Contract><![CDATA[
/* <MODULE_CONTRACT id="MC-shared-kernel-logging-LogSanitizer">
     <Purpose>Provide utilities to sanitize user input before logging to prevent log injection attacks</Purpose>
     <Responsibilities>
       <Item>Sanitize strings by removing/escaping newlines, carriage returns, tabs</Item>
       <Item>Remove ANSI escape sequences that could manipulate terminal output</Item>
       <Item>Handle null input gracefully</Item>
       <Item>Provide batch sanitization for maps</Item>
     </Responsibilities>
     <Dependencies>
       <Item>org.owasp.encoder:encoder:1.2.3</Item>
     </Dependencies>
     <LINKS>
       <Link ref="Technology.xml#DEC-SEC-LOG-SANITIZATION"/>
       <Link ref="DevelopmentPlan.xml#DP-SVC-shared-kernel"/>
     </LINKS>
   </MODULE_CONTRACT> */
        ]]></Contract>
        <Implementation><![CDATA[
package com.kanokna.shared.logging;

import org.owasp.encoder.Encode;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Utility class to sanitize user input before logging.
 * Prevents log injection attacks by removing/escaping control characters.
 *
 * @see <a href="https://owasp.org/www-community/attacks/Log_Injection">OWASP Log Injection</a>
 */
/* <MODULE_CONTRACT id="MC-shared-kernel-logging-LogSanitizer">
     <Purpose>Provide utilities to sanitize user input before logging to prevent log injection attacks</Purpose>
     <Responsibilities>
       <Item>Sanitize strings by removing/escaping newlines, carriage returns, tabs</Item>
       <Item>Remove ANSI escape sequences that could manipulate terminal output</Item>
       <Item>Handle null input gracefully</Item>
       <Item>Provide batch sanitization for maps</Item>
     </Responsibilities>
     <Dependencies>
       <Item>org.owasp.encoder:encoder:1.2.3</Item>
     </Dependencies>
     <LINKS>
       <Link ref="Technology.xml#DEC-SEC-LOG-SANITIZATION"/>
       <Link ref="DevelopmentPlan.xml#DP-SVC-shared-kernel"/>
     </LINKS>
   </MODULE_CONTRACT> */
public final class LogSanitizer {

    // ANSI escape sequence pattern: ESC[ followed by parameters and command
    private static final String ANSI_PATTERN = "\\x1B\\[[0-9;]*[a-zA-Z]";

    private LogSanitizer() {
        // Utility class - prevent instantiation
    }

    /**
     * Sanitizes a string for safe logging.
     * Removes newlines, carriage returns, tabs, and ANSI escape sequences.
     *
     * @param input the input string (may be null)
     * @return sanitized string safe for logging, or "[null]" if input is null
     */
    /* <FUNCTION_CONTRACT id="FC-logsanitizer-sanitize">
         <Signature>public static String sanitize(String input)</Signature>
         <Preconditions>
           <Item>None - accepts any input including null</Item>
         </Preconditions>
         <Postconditions>
           <Item>Returns non-null string</Item>
           <Item>Output contains no newlines (\n), carriage returns (\r), or tabs (\t)</Item>
           <Item>Output contains no ANSI escape sequences</Item>
         </Postconditions>
         <TEST_CASES>
           <TestCase id="TC-LOG-SANITIZE-001">Input with newlines returns string with newlines replaced</TestCase>
           <TestCase id="TC-LOG-SANITIZE-002">Input with ANSI escapes returns string with escapes removed</TestCase>
           <TestCase id="TC-LOG-SANITIZE-003">Normal string passes through unchanged</TestCase>
           <TestCase id="TC-LOG-SANITIZE-004">Null input returns "[null]"</TestCase>
         </TEST_CASES>
         <LINKS>
           <Link ref="MC-shared-kernel-logging-LogSanitizer"/>
         </LINKS>
       </FUNCTION_CONTRACT> */
    public static String sanitize(String input) {
        if (input == null) {
            return "[null]";
        }

        // Use OWASP Encoder for Java string encoding (escapes special chars)
        String encoded = Encode.forJava(input);

        // Remove ANSI escape sequences
        encoded = encoded.replaceAll(ANSI_PATTERN, "");

        return encoded;
    }

    /**
     * Sanitizes all values in a map for safe logging.
     *
     * @param input the input map (may be null)
     * @return new map with sanitized string values, or empty map if input is null
     */
    /* <FUNCTION_CONTRACT id="FC-logsanitizer-sanitizeMap">
         <Signature>public static Map&lt;String, String&gt; sanitizeMap(Map&lt;String, ?&gt; input)</Signature>
         <Preconditions>
           <Item>None - accepts any input including null</Item>
         </Preconditions>
         <Postconditions>
           <Item>Returns non-null map</Item>
           <Item>All values are sanitized strings</Item>
           <Item>Original map is not modified</Item>
         </Postconditions>
         <LINKS>
           <Link ref="MC-shared-kernel-logging-LogSanitizer"/>
         </LINKS>
       </FUNCTION_CONTRACT> */
    public static Map<String, String> sanitizeMap(Map<String, ?> input) {
        if (input == null) {
            return Map.of();
        }

        Map<String, String> result = new LinkedHashMap<>();
        for (Map.Entry<String, ?> entry : input.entrySet()) {
            String key = sanitize(entry.getKey());
            String value = entry.getValue() == null ? "[null]" : sanitize(entry.getValue().toString());
            result.put(key, value);
        }
        return result;
    }
}
        ]]></Implementation>
      </File>

      <File action="CREATE" priority="3">
        <Path>shared/shared-kernel/src/test/java/com/kanokna/shared/logging/LogSanitizerTest.java</Path>
        <Purpose>Test cases for LogSanitizer per TC-LOG-SANITIZE-*</Purpose>
        <Implementation><![CDATA[
package com.kanokna.shared.logging;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.LinkedHashMap;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Tests for {@link LogSanitizer}.
 */
class LogSanitizerTest {

    // TC-LOG-SANITIZE-001: Newline injection sanitized
    @Test
    @DisplayName("TC-LOG-SANITIZE-001: sanitize removes newlines and carriage returns")
    void sanitize_removesNewlinesAndCarriageReturns() {
        String malicious = "user\n[ADMIN] Elevated\rto admin";

        String result = LogSanitizer.sanitize(malicious);

        assertThat(result).doesNotContain("\n");
        assertThat(result).doesNotContain("\r");
        // OWASP encoder escapes these as \\n and \\r
        assertThat(result).contains("\\n");
        assertThat(result).contains("\\r");
    }

    // TC-LOG-SANITIZE-002: ANSI escape sequences sanitized
    @Test
    @DisplayName("TC-LOG-SANITIZE-002: sanitize removes ANSI escape sequences")
    void sanitize_removesAnsiEscapeSequences() {
        String malicious = "normal\u001B[31mRED_TEXT\u001B[0m";

        String result = LogSanitizer.sanitize(malicious);

        assertThat(result).doesNotContain("\u001B");
        assertThat(result).doesNotContain("[31m");
        assertThat(result).doesNotContain("[0m");
    }

    // TC-LOG-SANITIZE-003: Normal strings unchanged
    @Test
    @DisplayName("TC-LOG-SANITIZE-003: sanitize leaves normal strings unchanged")
    void sanitize_normalStringsUnchanged() {
        String normal = "productTemplateId-12345-window";

        String result = LogSanitizer.sanitize(normal);

        assertThat(result).isEqualTo(normal);
    }

    // TC-LOG-SANITIZE-004: Null input handling
    @Test
    @DisplayName("TC-LOG-SANITIZE-004: sanitize handles null input gracefully")
    void sanitize_nullInputReturnsNullMarker() {
        String result = LogSanitizer.sanitize(null);

        assertThat(result).isEqualTo("[null]");
    }

    @Test
    @DisplayName("sanitize handles tabs")
    void sanitize_handlesTabs() {
        String input = "col1\tcol2\tcol3";

        String result = LogSanitizer.sanitize(input);

        assertThat(result).doesNotContain("\t");
    }

    @Test
    @DisplayName("sanitizeMap sanitizes all values")
    void sanitizeMap_sanitizesAllValues() {
        Map<String, Object> input = new LinkedHashMap<>();
        input.put("user", "normal");
        input.put("evil", "bad\ninjection");
        input.put("nullable", null);

        Map<String, String> result = LogSanitizer.sanitizeMap(input);

        assertThat(result).hasSize(3);
        assertThat(result.get("user")).isEqualTo("normal");
        assertThat(result.get("evil")).doesNotContain("\n");
        assertThat(result.get("nullable")).isEqualTo("[null]");
    }

    @Test
    @DisplayName("sanitizeMap handles null map")
    void sanitizeMap_nullMapReturnsEmptyMap() {
        Map<String, String> result = LogSanitizer.sanitizeMap(null);

        assertThat(result).isEmpty();
    }
}
        ]]></Implementation>
      </File>

      <File action="UPDATE" priority="4">
        <Path>services/pricing-service/src/main/java/com/kanokna/pricing/application/service/PriceCalculationUseCaseService.java</Path>
        <Purpose>Fix log injection at lines 110 and 203</Purpose>
        <Changes>
          <Change location="imports">
            <Add>import com.kanokna.shared.logging.LogSanitizer;</Add>
          </Change>
          <Change location="line 110">
            <Before>command.getProductTemplateId()</Before>
            <After>LogSanitizer.sanitize(command.getProductTemplateId())</After>
          </Change>
          <Change location="line 203 (logPromoDecision method)">
            <Before>decision, promoCode</Before>
            <After>decision, LogSanitizer.sanitize(promoCode)</After>
          </Change>
        </Changes>
      </File>
    </FileGroup>

    <!-- TG-2: HIGH SEVERITY - CSRF Documentation -->
    <FileGroup id="TG-2" name="CSRF Documentation (HIGH)">
      <CSRFComment><![CDATA[
        // CSRF protection is intentionally disabled per DEC-SEC-CSRF-STATELESS:
        // - All APIs use stateless JWT bearer token authentication (no cookies)
        // - No browser-based form submissions or cookie-based sessions
        // - CSRF attacks require cookie-based auth which is not present
        // See: Technology.xml#DEC-SEC-CSRF-STATELESS
      ]]></CSRFComment>

      <File action="UPDATE">
        <Path>config-server/src/main/java/com/kanokna/config_server/config/SecurityConfig.java</Path>
        <Purpose>Add CSRF explanation comment before .csrf() line</Purpose>
        <Line>65</Line>
      </File>

      <File action="UPDATE">
        <Path>gateway/src/main/java/com/kanokna/gateway/config/SecurityConfig.java</Path>
        <Purpose>Add CSRF explanation comment before .csrf() line</Purpose>
        <Line>83</Line>
      </File>

      <File action="UPDATE">
        <Path>services/pricing-service/src/main/java/com/kanokna/pricing/adapters/config/SecurityConfig.java</Path>
        <Purpose>Add CSRF explanation comment before .csrf() line</Purpose>
        <Line>23</Line>
      </File>

      <File action="UPDATE">
        <Path>services/account-service/src/main/java/com/kanokna/account/adapters/config/SecurityConfig.java</Path>
        <Purpose>Add CSRF explanation comment before .csrf() line</Purpose>
        <Line>21</Line>
      </File>

      <File action="UPDATE">
        <Path>services/cart-service/src/main/java/com/kanokna/cart/adapters/config/SecurityConfig.java</Path>
        <Purpose>Add CSRF explanation comment before .csrf() line</Purpose>
        <Line>21</Line>
      </File>

      <File action="UPDATE">
        <Path>services/catalog-configuration-service/src/main/java/com/kanokna/catalog/adapters/config/SecurityConfig.java</Path>
        <Purpose>Add CSRF explanation comment before .csrf() line</Purpose>
        <Line>23</Line>
      </File>

      <File action="UPDATE">
        <Path>services/search-service/src/main/java/com/kanokna/search/adapters/config/SecurityConfig.java</Path>
        <Purpose>Add CSRF explanation comment before .csrf() line</Purpose>
        <Line>22</Line>
      </File>
    </FileGroup>

    <!-- TG-3: CodeQL Configuration -->
    <FileGroup id="TG-3" name="CodeQL Configuration (HIGH)">
      <File action="CREATE">
        <Path>.github/codeql-config.yml</Path>
        <Purpose>CodeQL exclusions per DEC-SEC-CODEQL-EXCLUSIONS</Purpose>
        <Implementation><![CDATA[
# ============================================================================
# CodeQL Configuration for Kanokna Windows Store
# ============================================================================
# Decision Reference: DEC-SEC-CODEQL-EXCLUSIONS
# See: Technology.xml#DEC-SEC-CODEQL-EXCLUSIONS
# ============================================================================

name: "Kanokna CodeQL Config"

# Exclude generated sources from analysis
paths-ignore:
  - '**/target/generated-sources/**'
  - '**/target/generated-test-sources/**'
  - '**/generated/**'
  - '**/*Proto.java'
  - '**/*Grpc.java'

# Suppress specific rules with documented justification
query-filters:
  - exclude:
      id: java/spring-disabled-csrf-protection
      # Justification: DEC-SEC-CSRF-STATELESS
      # All APIs use stateless JWT bearer token authentication.
      # CSRF protection is not needed for APIs that don't use cookies/sessions.
      # See: Technology.xml#DEC-SEC-CSRF-STATELESS
        ]]></Implementation>
      </File>

      <File action="UPDATE">
        <Path>.github/workflows/codeql.yml</Path>
        <Purpose>Reference new codeql-config.yml</Purpose>
        <Change location="Initialize CodeQL step (around line 68)">
          <Before><![CDATA[
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: java
          build-mode: manual
          # Use extended security queries for comprehensive analysis
          queries: +security-extended,security-and-quality
          ]]></Before>
          <After><![CDATA[
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: java
          build-mode: manual
          config-file: ./.github/codeql-config.yml
          # Use extended security queries for comprehensive analysis
          queries: +security-extended,security-and-quality
          ]]></After>
        </Change>
      </File>
    </FileGroup>

    <!-- TG-4: Code Quality Fixes -->
    <FileGroup id="TG-4" name="Code Quality Fixes (MEDIUM)">
      <File action="UPDATE">
        <Path>services/account-service/src/main/java/com/kanokna/account/application/service/AddressService.java</Path>
        <Purpose>Fix null dereference at line 186</Purpose>
        <Line>186</Line>
        <Analysis>
          profile.addAddress() may return null. The returned savedAddress is used on line 191
          in a filter comparison. Fix by using Objects.requireNonNull or adding explicit null check.
        </Analysis>
        <Fix><![CDATA[
// Replace line 186:
SavedAddress savedAddress = profile.addAddress(addressDto.toValueObject(), command.label(), command.setAsDefault(), now);

// With null check:
SavedAddress savedAddress = Objects.requireNonNull(
    profile.addAddress(addressDto.toValueObject(), command.label(), command.setAsDefault(), now),
    "Profile.addAddress must not return null"
);
        ]]></Fix>
      </File>

      <File action="UPDATE">
        <Path>services/search-service/src/main/java/com/kanokna/search/adapters/out/elasticsearch/ElasticsearchSearchRepository.java</Path>
        <Purpose>Fix missing switch case at line 316</Purpose>
        <Line>316</Line>
        <Analysis>
          Switch on SortField enum may be missing cases. Add default case for future-proofing.
        </Analysis>
        <Fix><![CDATA[
// At end of switch statement (after RELEVANCE, UNSPECIFIED case), add:
default -> {
    // Future enum values default to relevance scoring
}
        ]]></Fix>
      </File>

      <File action="UPDATE">
        <Path>services/cart-service/src/main/java/com/kanokna/cart/application/service/CartPricingService.java</Path>
        <Purpose>Fix unread variable at line 152</Purpose>
        <Line>152</Line>
        <Analysis>
          Variable 'now' is declared but never used. Either remove it or use it.
        </Analysis>
        <Fix>Remove the unused variable declaration: Instant now = Instant.now();</Fix>
      </File>

      <File action="UPDATE">
        <Path>services/catalog-configuration-service/src/main/java/com/kanokna/catalog/domain/service/BomResolutionService.java</Path>
        <Purpose>Fix uncaught NumberFormatException at lines 131, 134, 136</Purpose>
        <Lines>131, 134, 136</Lines>
        <Analysis>
          Integer.parseInt and Double.parseDouble can throw NumberFormatException.
          Wrap in try-catch with domain-appropriate error handling.
        </Analysis>
        <Fix><![CDATA[
// Wrap the evaluateExpression method body in try-catch:
private int evaluateExpression(String expression) {
    expression = expression.trim();
    try {
        if (expression.contains("/")) {
            String[] parts = expression.split("/");
            return (int) Math.ceil(Double.parseDouble(parts[0].trim()) / Double.parseDouble(parts[1].trim()));
        } else if (expression.contains("*")) {
            String[] parts = expression.split("\\*");
            return (int) (Double.parseDouble(parts[0].trim()) * Double.parseDouble(parts[1].trim()));
        } else {
            return Integer.parseInt(expression);
        }
    } catch (NumberFormatException e) {
        throw new IllegalArgumentException("Invalid numeric expression: " + expression, e);
    }
}
        ]]></Fix>
      </File>

      <File action="UPDATE">
        <Path>services/search-service/src/main/java/com/kanokna/search/adapters/config/JacksonConfig.java</Path>
        <Purpose>Fix deprecated API call at line 30</Purpose>
        <Line>30</Line>
        <Analysis>
          In Jackson 3.x, ObjectMapper construction or configuration methods may have changed.
          Check Spring Boot 4.0/Jackson 3.0 documentation for current API.
          If ObjectMapper() constructor is deprecated, use JsonMapper.builder().build().
        </Analysis>
        <Fix><![CDATA[
// If ObjectMapper() is deprecated in Jackson 3.x, replace with:
import com.fasterxml.jackson.databind.json.JsonMapper;

@Bean
@Primary
public ObjectMapper objectMapper() {
    return JsonMapper.builder()
        .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
        .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
        .serializationInclusion(JsonInclude.Include.NON_NULL)
        .build();
}
        ]]></Fix>
      </File>

      <File action="UPDATE" optional="true">
        <Path>Multiple files - unused parameters</Path>
        <Purpose>Address unused parameters where practical</Purpose>
        <Note>
          Review ~20 unused parameter alerts. Many are in gRPC client stubs where
          parameters may be required by interface but unused in current implementation.
          Options:
          (A) Remove if not needed
          (B) Prefix with underscore: _unusedParam
          (C) Add @SuppressWarnings("unused") with comment explaining why

          Priority: LOW - address if time permits
        </Note>
      </File>
    </FileGroup>
  </FilePlan>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       REQUIRED OUTPUTS
       ═══════════════════════════════════════════════════════════════════════════ -->
  <RequiredOutputs>
    <Item>FilePlan execution report (paths + status)</Item>
    <Item>LogSanitizerTest passes all 4 TC-* cases</Item>
    <Item>mvn clean verify succeeds on all modules</Item>
    <Item>ConsistencyChecklist (self-audit vs scope + contracts)</Item>
    <Item>GitExecutionSteps: exact git/gh commands executed</Item>
    <Item>PR link + CI status summary</Item>
  </RequiredOutputs>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       ACCEPTANCE CRITERIA FOR CODER
       ═══════════════════════════════════════════════════════════════════════════ -->
  <AcceptanceCriteria>
    <Criterion id="AC-IMPL-1">LogSanitizer.java created in shared-kernel with OWASP Encoder</Criterion>
    <Criterion id="AC-IMPL-2">LogSanitizerTest.java passes all 4 test cases</Criterion>
    <Criterion id="AC-IMPL-3">PriceCalculationUseCaseService uses LogSanitizer for user input logging</Criterion>
    <Criterion id="AC-IMPL-4">All SecurityConfig files have CSRF explanation comment</Criterion>
    <Criterion id="AC-IMPL-5">.github/codeql-config.yml created with exclusions</Criterion>
    <Criterion id="AC-IMPL-6">codeql.yml workflow references new config file</Criterion>
    <Criterion id="AC-IMPL-7">All code quality fixes applied (null deref, switch case, unread var, NFE)</Criterion>
    <Criterion id="AC-IMPL-8">mvn clean verify succeeds on all affected modules</Criterion>
  </AcceptanceCriteria>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       VERIFICATION STEPS
       ═══════════════════════════════════════════════════════════════════════════ -->
  <Verification>
    <Step order="1">mvn clean verify -pl shared/shared-kernel (LogSanitizer tests)</Step>
    <Step order="2">mvn clean verify -pl services/pricing-service</Step>
    <Step order="3">mvn clean verify -pl services/account-service</Step>
    <Step order="4">mvn clean verify -pl services/cart-service</Step>
    <Step order="5">mvn clean verify -pl services/search-service</Step>
    <Step order="6">mvn clean verify -pl services/catalog-configuration-service</Step>
    <Step order="7">mvn clean verify (full build)</Step>
    <Step order="8">Push branch and create PR</Step>
    <Step order="9">Verify CodeQL workflow picks up new config</Step>
  </Verification>
</CODER_WORK_ORDER>
