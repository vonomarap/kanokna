<?xml version="1.0" encoding="UTF-8"?>
<!--
  GRACE Canonical Artifact: Technology.xml
  Purpose: Define approved technology stack, versions, and cross-cutting technical decisions
  Version: 1.4.0
  Last Updated: 2026-01-09T16:00:00+03:00
  Changes: v1.4.0 - Added DEC-CART-* decisions from Handoff-20260109-01-W1-T6-CartService
           v1.3.0 - Added DEC-DISTRIBUTED-LOCK for search-service reindex (ISS-SEARCH-BLUEPRINT-002)
           v1.2.0 - Added DEC-PRICING-* decisions from Handoff-20251231-02
           v1.1.0 - Promoted DEC-CATALOG-RULE-ENGINE and DEC-CATALOG-VERSIONING from Handoff-20251230-07
           as architectural patterns DEC-ARCH-RULE-ENGINE-STRATEGY and DEC-ARCH-ENTITY-VERSIONING
-->
<Technology version="1.4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

  <!-- ═══════════════════════════════════════════════════════════════════════════
       LANGUAGES
       ═══════════════════════════════════════════════════════════════════════════ -->
  <Languages>
    <Language id="TECH-java">
      <Name>Java</Name>
      <Version>25</Version>
      <Usage>Primary backend language for all services</Usage>
      <Notes>
        Using latest LTS features: records, sealed classes, pattern matching, virtual threads.
        Preview features enabled selectively in dev profile only.
      </Notes>
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-shared-kernel" />
      </Links>
    </Language>
  </Languages>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       FRAMEWORKS
       ═══════════════════════════════════════════════════════════════════════════ -->
  <Frameworks>
    <Framework id="TECH-spring-boot">
      <Name>Spring Boot</Name>
      <Version status="TBD">4.0.0</Version>
      <Usage>Foundation for all microservices</Usage>
      <Notes>
        Spring Boot 4.0.0 is declared in parent POM. version placeholder retained from project POM.
        Implementation should verify API compatibility when actual release is available.
      </Notes>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-MAINT-MODULARITY" />
      </Links>
    </Framework>

    <Framework id="TECH-spring-cloud">
      <Name>Spring Cloud</Name>
      <Version>2024.0.0</Version>
      <Usage>Service discovery, configuration, resilience patterns</Usage>
      <Components>
        <Component name="spring-cloud-config">Centralized configuration (config-server)</Component>
        <Component name="spring-cloud-gateway">API Gateway routing and filtering</Component>
        <Component name="spring-cloud-circuitbreaker">Circuit breaker abstraction</Component>
      </Components>
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-config-server" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-gateway" />
      </Links>
    </Framework>

    <Framework id="TECH-grpc">
      <Name>gRPC</Name>
      <Version>1.60.x</Version>
      <Usage>Synchronous inter-service communication</Usage>
      <Components>
        <Component name="grpc-spring-boot-starter">gRPC server and client integration</Component>
        <Component name="protobuf-java">Protocol Buffers runtime</Component>
        <Component name="grpc-netty-shaded">Netty transport</Component>
      </Components>
      <Configuration>
        <Item>Service definitions in api-contracts module (.proto files)</Item>
        <Item>Generated stubs used in adapters.out.grpc packages</Item>
        <Item>Deadline propagation for timeout management</Item>
        <Item>Interceptors for tracing and authentication</Item>
        <Item>Health checks via gRPC Health Checking Protocol</Item>
      </Configuration>
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-api-contracts" />
        <Link ref="Technology.xml#TECH-protobuf" />
      </Links>
    </Framework>

    <Framework id="TECH-spring-security">
      <Name>Spring Security</Name>
      <Version>Managed by Spring Boot BOM</Version>
      <Usage>Authentication, authorization, OAuth2 resource server</Usage>
      <Configuration>
        <Item>All services act as OAuth2 Resource Servers validating JWT tokens</Item>
        <Item>Gateway performs initial authentication; services re-validate</Item>
        <Item>Method-level security with @PreAuthorize for role-based access</Item>
      </Configuration>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-SEC-AUTHENTICATION" />
        <Link ref="RequirementsAnalysis.xml#NFR-SEC-RBAC" />
      </Links>
    </Framework>

    <Framework id="TECH-spring-data-jpa">
      <Name>Spring Data JPA</Name>
      <Version>Managed by Spring Boot BOM</Version>
      <Usage>Repository abstraction for relational data access</Usage>
      <Configuration>
        <Item>Custom repository implementations for complex queries</Item>
        <Item>Projections for read-optimized queries</Item>
        <Item>Auditing enabled for created/modified timestamps</Item>
      </Configuration>
      <Links>
        <Link ref="Technology.xml#TECH-hibernate-jpa" />
      </Links>
    </Framework>

    <Framework id="TECH-hibernate-jpa">
      <Name>Hibernate ORM</Name>
      <Version>Managed by Spring Boot BOM</Version>
      <Usage>JPA implementation</Usage>
      <Configuration>
        <Item>ddl-auto=validate in all profiles (Flyway handles migrations)</Item>
        <Item>Open-session-in-view disabled</Item>
        <Item>Batch fetching enabled (default_batch_fetch_size=25)</Item>
        <Item>Second-level cache disabled initially; enable per-entity as needed</Item>
      </Configuration>
      <Guidelines>
        <Item>Use JPA API primarily; Hibernate extensions only when necessary</Item>
        <Item>Entities have no-arg constructor; LAZY associations not final</Item>
        <Item>equals/hashCode by business key, not DB id</Item>
        <Item>Avoid N+1: use @EntityGraph, JOIN FETCH, or batch fetching</Item>
      </Guidelines>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-MAINT-MODULARITY" />
      </Links>
    </Framework>

    <Framework id="TECH-jakarta-validation">
      <Name>Jakarta Bean Validation</Name>
      <Version>3.1</Version>
      <Usage>Input validation in adapters and application DTOs</Usage>
      <Configuration>
        <Item>Validation at REST controller boundaries (@Valid)</Item>
        <Item>Custom validators for domain-specific rules</Item>
        <Item>Domain invariants enforced in domain layer (not via annotations)</Item>
      </Configuration>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-SEC-INPUT-VALIDATION" />
      </Links>
    </Framework>

    <Framework id="TECH-mapstruct">
      <Name>MapStruct</Name>
      <Version>1.5.5.Final</Version>
      <Usage>Type-safe mapping between layers (DTO to domain, entity to domain)</Usage>
      <Configuration>
        <Item>Mappers in adapter layer only</Item>
        <Item>ComponentModel = spring for dependency injection</Item>
      </Configuration>
    </Framework>
  </Frameworks>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       INFRASTRUCTURE
       ═══════════════════════════════════════════════════════════════════════════ -->
  <Infrastructure>
    <!-- Databases -->
    <Database id="TECH-postgresql">
      <Name>PostgreSQL</Name>
      <Version>16</Version>
      <Usage>Primary OLTP database for all services</Usage>
      <Configuration>
        <Item>Each service has its own database (logical or physical)</Item>
        <Item>Connection pooling via HikariCP (default Spring Boot pool)</Item>
        <Item>Schema migrations via Flyway</Item>
      </Configuration>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-SCALE-DB-PER-SERVICE" />
      </Links>
    </Database>

    <Database id="TECH-flyway">
      <Name>Flyway</Name>
      <Version>10.x</Version>
      <Usage>Database schema migrations</Usage>
      <Configuration>
        <Item>Migration scripts in src/main/resources/db/migration</Item>
        <Item>Versioned migrations (V1__, V2__, ...)</Item>
        <Item>Repeatable migrations for views/functions (R__)</Item>
        <Item>Baseline on existing databases if needed</Item>
      </Configuration>
    </Database>

    <!-- Search -->
    <SearchEngine id="TECH-elasticsearch">
      <Name>Elasticsearch</Name>
      <Version>8.x</Version>
      <Usage>Full-text search, faceted filtering, autocomplete for products</Usage>
      <Configuration>
        <Item>Dedicated search-service manages indices</Item>
        <Item>Async indexing triggered by domain events from catalog-configuration-service</Item>
        <Item>Index aliases for zero-downtime reindexing</Item>
      </Configuration>
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-search-service" />
        <Link ref="RequirementsAnalysis.xml#NFR-PERF-SEARCH-LATENCY" />
      </Links>
    </SearchEngine>

    <!-- Messaging -->
    <MessageBroker id="TECH-kafka">
      <Name>Apache Kafka</Name>
      <Version>3.7.x</Version>
      <Usage>Asynchronous event-driven communication between services</Usage>
      <Configuration>
        <Item>Topics per domain event type (e.g., order.created, order.shipped)</Item>
        <Item>Consumer groups per consuming service</Item>
        <Item>Outbox pattern for reliable event publishing</Item>
        <Item>Idempotent consumers with message ID deduplication</Item>
        <Item>Schema Registry for Protobuf schema management</Item>
      </Configuration>
      <Topics>
        <Topic name="catalog.product.published">Product catalog updates</Topic>
        <Topic name="order.created">New order events</Topic>
        <Topic name="order.status.changed">Order status transitions</Topic>
        <Topic name="payment.captured">Payment capture confirmations</Topic>
        <Topic name="installation.scheduled">Installation appointment events</Topic>
      </Topics>
      <Links>
        <Link ref="DevelopmentPlan.xml#Flow-Event-Driven" />
      </Links>
    </MessageBroker>

    <!-- Caching -->
    <Cache id="TECH-redis">
      <Name>Redis</Name>
      <Version>7.x</Version>
      <Usage>Caching, session storage, rate limiting</Usage>
      <Configuration>
        <Item>Price quote caching (TTL: 5 minutes)</Item>
        <Item>Session data for anonymous carts</Item>
        <Item>Distributed rate limiting counters</Item>
        <Item>Jackson serializer for cache values</Item>
      </Configuration>
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-pricing-service" />
      </Links>
    </Cache>

    <!-- Object Storage -->
    <ObjectStorage id="TECH-s3-compatible">
      <Name>S3-Compatible Object Storage</Name>
      <Provider status="ASSUMED">MinIO (dev/stage), AWS S3 (prod)</Provider>
      <Usage>Product images, renders, installation manuals, user uploads</Usage>
      <Configuration>
        <Item>media-service manages metadata; objects stored in S3</Item>
        <Item>Presigned URLs for direct browser upload/download</Item>
        <Item>Image variants generated on upload (thumbnail, web, original)</Item>
        <Item>CDN (CloudFront) in front for production</Item>
      </Configuration>
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-media-service" />
        <Link ref="RequirementsAnalysis.xml#UC-MEDIA-SERVE" />
      </Links>
    </ObjectStorage>
  </Infrastructure>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       CROSS-CUTTING CONCERNS
       ═══════════════════════════════════════════════════════════════════════════ -->
  <CrossCutting>
    <!-- Security -->
    <Security id="TECH-security-stack">
      <IdentityProvider id="TECH-identity-provider">
        <Name>OAuth2/OIDC Identity Provider</Name>
        <Environments>
          <Environment name="dev-stage" id="TECH-keycloak">
            <Provider>Keycloak</Provider>
            <Version>24.x</Version>
            <Usage>Self-hosted OIDC for development and staging</Usage>
            <Configuration>
              <Item>Realm: kanokna</Item>
              <Item>Clients: web-frontend, mobile-app, admin-console</Item>
              <Item>Roles: CUSTOMER, INSTALLER, ADMIN, PRICING_ADMIN, CATALOG_ADMIN,
                REPORTING_VIEWER</Item>
              <Item>JWT tokens with RS256 signing</Item>
              <Item>Deployed via Docker Compose (dev) or Helm (stage)</Item>
            </Configuration>
          </Environment>
          <Environment name="prod" id="TECH-auth0">
            <Provider>Auth0</Provider>
            <Usage>Managed OIDC for production (reduced operational burden)</Usage>
            <Configuration>
              <Item>Tenant: kanokna-prod</Item>
              <Item>Applications: web-frontend, mobile-app, admin-console</Item>
              <Item>Roles mapped to JWT claims</Item>
              <Item>Social login support (Google, Facebook) if needed</Item>
              <Item>MFA enforcement for admin roles</Item>
              <Item>Branding customization for login pages</Item>
            </Configuration>
          </Environment>
        </Environments>
        <CommonConfiguration>
          <Item>All services validate JWT tokens as OAuth2 Resource Servers</Item>
          <Item>Token issuer URL configured per environment</Item>
          <Item>JWKS endpoint for public key retrieval</Item>
          <Item>Standard claims: sub, email, roles, permissions</Item>
        </CommonConfiguration>
        <Links>
          <Link ref="RequirementsAnalysis.xml#ACT-IDENTITY-PROVIDER" />
          <Link ref="RequirementsAnalysis.xml#NFR-SEC-AUTHENTICATION" />
        </Links>
      </IdentityProvider>

      <PaymentIntegration id="TECH-payment-integration">
        <Provider id="TECH-yookassa" status="APPROVED">YooKassa (YooMoney)</Provider>
        <Usage>Payment processing, authorization, capture, refunds for Russian market</Usage>
        <Configuration>
          <Item>YooKassa Java SDK for payment creation and management</Item>
          <Item>Support for bank cards (Visa, Mastercard, Mir)</Item>
          <Item>Support for YooMoney wallet payments</Item>
          <Item>Support for SberPay, Tinkoff Pay, and other Russian payment methods</Item>
          <Item>Webhooks for async payment status updates (payment.succeeded, payment.canceled,
            refund.succeeded)</Item>
          <Item>Two-stage payments: authorize then capture (for orders with production lead time)</Item>
          <Item>Receipts generation for Russian Federal Tax Service (54-FZ compliance)</Item>
          <Item>PCI-DSS compliance via tokenization (no card data stored)</Item>
          <Item>Idempotency keys for safe retries</Item>
        </Configuration>
        <Credentials>
          <Item>Shop ID and Secret Key stored in Vault/K8s Secrets</Item>
          <Item>Separate credentials per environment (test/prod)</Item>
        </Credentials>
        <Links>
          <Link ref="RequirementsAnalysis.xml#ACT-PAYMENT-GATEWAY" />
          <Link ref="DevelopmentPlan.xml#DP-SVC-order-service" />
        </Links>
      </PaymentIntegration>

      <SecretsManagement>
        <Tool>Kubernetes Secrets (dev/stage), HashiCorp Vault (prod)</Tool>
        <Policy>No secrets in source code; inject via environment or volume mounts</Policy>
      </SecretsManagement>
    </Security>

    <!-- Observability -->
    <Observability id="TECH-observability-stack">
      <Logging id="TECH-logging">
        <Format>JSON (Logstash encoder)</Format>
        <Library>logstash-logback-encoder 7.4</Library>
        <Configuration>
          <Item>Structured fields: traceId, spanId, correlationId, service, level, message</Item>
          <Item>MDC propagation for request context</Item>
          <Item>Log aggregation: ELK stack or Grafana Loki</Item>
        </Configuration>
        <Links>
          <Link ref="RequirementsAnalysis.xml#NFR-OBS-LOGGING" />
        </Links>
      </Logging>

      <Metrics id="TECH-micrometer">
        <Name>Micrometer</Name>
        <Version>Managed by Spring Boot BOM</Version>
        <Backend id="TECH-prometheus">
          <Name>Prometheus</Name>
          <Version>2.x</Version>
        </Backend>
        <Dashboards id="TECH-grafana">
          <Name>Grafana</Name>
          <Version>10.x</Version>
        </Dashboards>
        <Configuration>
          <Item>Spring Boot Actuator metrics exposed on /actuator/prometheus</Item>
          <Item>Custom business metrics via MeterRegistry</Item>
          <Item>Grafana dashboards for service health, latency, throughput</Item>
        </Configuration>
        <Links>
          <Link ref="RequirementsAnalysis.xml#NFR-OBS-METRICS" />
        </Links>
      </Metrics>

      <Tracing id="TECH-opentelemetry">
        <Name>OpenTelemetry</Name>
        <Version>1.x</Version>
        <Configuration>
          <Item>Auto-instrumentation via spring-boot-starter-actuator + micrometer-tracing</Item>
          <Item>Trace context propagation via W3C Trace Context headers</Item>
          <Item>Export to Jaeger or Tempo</Item>
        </Configuration>
        <Links>
          <Link ref="RequirementsAnalysis.xml#NFR-OBS-TRACING" />
        </Links>
      </Tracing>
    </Observability>

    <!-- Resilience -->
    <Resilience id="TECH-resilience4j">
      <Name>Resilience4j</Name>
      <Version>2.x</Version>
      <Usage>Circuit breakers, retries, timeouts, bulkheads, rate limiters</Usage>
      <Configuration>
        <Item>Circuit breaker on external service calls (payment gateway, notification providers)</Item>
        <Item>Retry with exponential backoff + jitter for transient failures</Item>
        <Item>Timeouts on all inter-service calls (default: 3s)</Item>
        <Item>Bulkhead isolation for critical paths</Item>
      </Configuration>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-AVAIL-GRACEFUL-DEGRADATION" />
      </Links>
    </Resilience>

    <!-- Feature Flags -->
    <FeatureFlags id="TECH-unleash">
      <Name>Unleash</Name>
      <Version status="ASSUMED">5.x</Version>
      <Usage>Feature toggles for gradual rollouts and A/B testing</Usage>
      <Configuration>
        <Item>SDK integrated in each service</Item>
        <Item>Flags for new features, pricing experiments, UI variations</Item>
      </Configuration>
    </FeatureFlags>

    <!-- API Documentation -->
    <ApiDocumentation id="TECH-springdoc">
      <Name>SpringDoc OpenAPI</Name>
      <Version status="TBD">2.x</Version>
      <Usage>Auto-generated OpenAPI specs and Swagger UI</Usage>
      <Configuration>
        <Item>OpenAPI 3.1 specs generated from controllers</Item>
        <Item>Swagger UI at /swagger-ui.html (dev/stage only)</Item>
        <Item>Contract-first: specs stored in docs/api-contracts/openapi</Item>
      </Configuration>
    </ApiDocumentation>
  </CrossCutting>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       SERIALIZATION
       ═══════════════════════════════════════════════════════════════════════════ -->
  <Serialization>
    <Format id="TECH-json-jackson">
      <Name>JSON (Jackson)</Name>
      <Usage>REST API request/response serialization</Usage>
      <Configuration>
        <Item>Java 8 date/time module enabled</Item>
        <Item>Fail on unknown properties: false</Item>
        <Item>Property naming: SNAKE_CASE for API, camelCase internally</Item>
      </Configuration>
    </Format>

    <Format id="TECH-protobuf">
      <Name>Protocol Buffers</Name>
      <Version>3.x</Version>
      <Usage>Kafka event serialization and gRPC inter-service communication</Usage>
      <Configuration>
        <Item>Service definitions (.proto) stored in api-contracts module</Item>
        <Item>Event schemas stored in docs/api-contracts/protobuf</Item>
        <Item>Schema Registry for versioning and compatibility checks</Item>
        <Item>Backward-compatible evolution: add optional fields, never remove/rename</Item>
        <Item>Generated Java classes via protobuf-maven-plugin</Item>
        <Item>gRPC stubs generated alongside message classes</Item>
      </Configuration>
      <ProtoStructure>
        <Directory>api-contracts/src/main/proto/</Directory>
        <Package pattern="com.kanokna.{service}.grpc">gRPC service definitions</Package>
        <Package pattern="com.kanokna.{service}.event">Domain event schemas</Package>
      </ProtoStructure>
      <Links>
        <Link ref="DevelopmentPlan.xml#ContractEvolutionPolicy" />
        <Link ref="Technology.xml#TECH-grpc" />
      </Links>
    </Format>
  </Serialization>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       BUILD & DEPLOYMENT
       ═══════════════════════════════════════════════════════════════════════════ -->
  <BuildAndDeployment>
    <Build id="TECH-maven">
      <Name>Apache Maven</Name>
      <Version>3.9.x</Version>
      <Configuration>
        <Item>Multi-module project with parent POM</Item>
        <Item>Profiles: dev, stage, prod</Item>
        <Item>Plugin management centralized in parent</Item>
      </Configuration>
    </Build>

    <ContainerImage id="TECH-jib">
      <Name>Jib</Name>
      <Usage>Build OCI container images without Dockerfile</Usage>
      <Configuration>
        <Item>Base image: eclipse-temurin:25-jre</Item>
        <Item>Layered image for efficient caching</Item>
        <Item>Push to container registry on CI</Item>
      </Configuration>
    </ContainerImage>

    <Orchestration id="TECH-kubernetes">
      <Name>Kubernetes</Name>
      <Version>1.29+</Version>
      <Configuration>
        <Item>Helm charts for each service</Item>
        <Item>ConfigMaps for non-sensitive configuration</Item>
        <Item>Secrets for credentials</Item>
        <Item>HPA for horizontal scaling</Item>
        <Item>Readiness/liveness probes via Actuator health endpoints</Item>
      </Configuration>
    </Orchestration>

    <CI id="TECH-ci-pipeline">
      <Tool id="TECH-github-actions" status="APPROVED">GitHub Actions</Tool>
      <Repository>GitHub (github.com/vonomarap/kanokna)</Repository>
      <Workflows>
        <Workflow name="ci.yml" trigger="push, pull_request">
          <Stage order="1">Checkout and cache dependencies</Stage>
          <Stage order="2">Build with Maven (mvn verify -DskipTests)</Stage>
          <Stage order="3">Unit tests (mvn test)</Stage>
          <Stage order="4">Integration tests with Testcontainers</Stage>
          <Stage order="5">ArchUnit architecture tests</Stage>
          <Stage order="6">Contract tests (OpenAPI, Protobuf validation)</Stage>
          <Stage order="7">Security scan (SAST via CodeQL, dependency check via Dependabot)</Stage>
          <Stage order="8">Code coverage report (JaCoCo)</Stage>
        </Workflow>
        <Workflow name="build-and-push.yml" trigger="push to main">
          <Stage order="1">Build container images (Jib)</Stage>
          <Stage order="2">Push to GitHub Container Registry (ghcr.io)</Stage>
          <Stage order="3">Update image tags in Helm values</Stage>
        </Workflow>
        <Workflow name="deploy-stage.yml" trigger="workflow_dispatch, push to main">
          <Stage order="1">Deploy to stage environment (Kubernetes)</Stage>
          <Stage order="2">Run smoke tests</Stage>
          <Stage order="3">Run E2E tests (optional)</Stage>
        </Workflow>
        <Workflow name="deploy-prod.yml" trigger="workflow_dispatch (manual)">
          <Stage order="1">Require approval from CODEOWNERS</Stage>
          <Stage order="2">Deploy to production (Kubernetes)</Stage>
          <Stage order="3">Run smoke tests</Stage>
          <Stage order="4">Notify Slack/Teams on success/failure</Stage>
        </Workflow>
      </Workflows>
      <Configuration>
        <Item>Reusable workflows for common steps</Item>
        <Item>Matrix builds for multiple Java versions (if needed)</Item>
        <Item>Caching for Maven dependencies (.m2/repository)</Item>
        <Item>Secrets stored in GitHub Secrets</Item>
        <Item>Environment protection rules for prod</Item>
      </Configuration>
      <Links>
        <Link ref="Technology.xml#TECH-jib" />
        <Link ref="Technology.xml#TECH-kubernetes" />
      </Links>
    </CI>
  </BuildAndDeployment>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       TESTING
       ═══════════════════════════════════════════════════════════════════════════ -->
  <Testing>
    <Framework id="TECH-junit5">
      <Name>JUnit 5</Name>
      <Usage>Unit and integration test framework</Usage>
    </Framework>

    <Framework id="TECH-mockito">
      <Name>Mockito</Name>
      <Usage>Mocking for unit tests</Usage>
    </Framework>

    <Framework id="TECH-testcontainers">
      <Name>Testcontainers</Name>
      <Version>1.19.x</Version>
      <Usage>Integration tests with real dependencies (PostgreSQL, Kafka, Redis, Elasticsearch)</Usage>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-MAINT-TESTABILITY" />
      </Links>
    </Framework>

    <Framework id="TECH-archunit">
      <Name>ArchUnit</Name>
      <Version>1.2.x</Version>
      <Usage>Enforce architectural rules (hexagonal layers, dependency direction)</Usage>
      <Rules>
        <Rule>Domain layer must not depend on adapters or application layer</Rule>
        <Rule>Application layer must not depend on adapters</Rule>
        <Rule>No Spring annotations in domain layer</Rule>
        <Rule>No JPA annotations in domain layer</Rule>
      </Rules>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-MAINT-MODULARITY" />
      </Links>
    </Framework>

    <Framework id="TECH-contract-testing">
      <Name>Contract Testing</Name>
      <Tools>
        <Tool>OpenAPI contract validation (spectral, dredd)</Tool>
        <Tool>Spring Cloud Contract or Pact (optional)</Tool>
      </Tools>
      <Usage>Verify producer/consumer compatibility against published contracts</Usage>
    </Framework>
  </Testing>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       DECISIONS
       ═══════════════════════════════════════════════════════════════════════════ -->
  <Decisions>
    <Decision id="DEC-DB-ENGINE" status="APPROVED">
      <Title>Primary OLTP Database</Title>
      <Selected>PostgreSQL</Selected>
      <Alternatives>
        <Alternative>MySQL</Alternative>
        <Alternative>MariaDB</Alternative>
      </Alternatives>
      <Rationale>
        PostgreSQL offers superior support for JSON columns, full-text search fallback,
        and advanced data types. Strong community and cloud provider support.
      </Rationale>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-SCALE-DB-PER-SERVICE" />
      </Links>
    </Decision>

    <Decision id="DEC-SEARCH-ENGINE" status="APPROVED">
      <Title>Search Engine</Title>
      <Selected>Elasticsearch</Selected>
      <Alternatives>
        <Alternative>OpenSearch</Alternative>
        <Alternative>Typesense</Alternative>
        <Alternative>Meilisearch</Alternative>
      </Alternatives>
      <Rationale>
        Elasticsearch is industry standard for faceted search and autocomplete.
        Mature ecosystem, excellent Spring Data integration.
      </Rationale>
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-SEARCH-PRODUCTS" />
      </Links>
    </Decision>

    <Decision id="DEC-EVENT-SERIALIZATION" status="APPROVED">
      <Title>Event Serialization Format</Title>
      <Selected>Protobuf</Selected>
      <Alternatives>
        <Alternative>Avro</Alternative>
        <Alternative>JSON</Alternative>
      </Alternatives>
      <Rationale>
        Protobuf provides compact binary format, strong typing, and schema evolution.
        Schema Registry integration ensures compatibility.
      </Rationale>
      <Links>
        <Link ref="DevelopmentPlan.xml#ContractEvolutionPolicy" />
      </Links>
    </Decision>

    <Decision id="DEC-IDENTITY-PROVIDER" status="APPROVED">
      <Title>Identity Provider (Environment-Specific)</Title>
      <Selected>Keycloak (dev/stage), Auth0 (prod)</Selected>
      <Alternatives>
        <Alternative>Okta</Alternative>
        <Alternative>AWS Cognito</Alternative>
        <Alternative>Keycloak for all environments</Alternative>
      </Alternatives>
      <Rationale>
        Keycloak provides full OAuth2/OIDC support for dev/stage with easy Docker deployment.
        Auth0 for production reduces operational and security burden with managed infrastructure,
        automatic security updates, and enterprise-grade SLAs.
      </Rationale>
      <Links>
        <Link ref="RequirementsAnalysis.xml#ACT-IDENTITY-PROVIDER" />
        <Link ref="Technology.xml#TECH-keycloak" />
        <Link ref="Technology.xml#TECH-auth0" />
      </Links>
    </Decision>

    <Decision id="DEC-PAYMENT-GATEWAY" status="APPROVED">
      <Title>Payment Gateway Provider</Title>
      <Selected>YooKassa (YooMoney)</Selected>
      <Alternatives>
        <Alternative>Stripe</Alternative>
        <Alternative>Tinkoff Acquiring</Alternative>
        <Alternative>Sberbank Acquiring</Alternative>
      </Alternatives>
      <Rationale>
        YooKassa is the primary payment gateway for the Russian market.
        Supports all major Russian payment methods (Mir, SberPay, YooMoney wallet),
        provides 54-FZ compliant receipts, and has robust API and webhook infrastructure.
        Stripe is not optimal for Russia-focused MVP.
      </Rationale>
      <Links>
        <Link ref="RequirementsAnalysis.xml#ACT-PAYMENT-GATEWAY" />
        <Link ref="Technology.xml#TECH-yookassa" />
      </Links>
    </Decision>

    <Decision id="DEC-INTER-SERVICE-COMM" status="APPROVED">
      <Title>Inter-Service Communication Protocol</Title>
      <Selected>gRPC</Selected>
      <Alternatives>
        <Alternative>REST (HTTP/JSON)</Alternative>
        <Alternative>GraphQL Federation</Alternative>
      </Alternatives>
      <Rationale>
        gRPC provides efficient binary serialization (Protobuf), strong typing via
        service definitions, streaming support, and excellent performance for
        synchronous inter-service calls. Contract-first approach aligns with
        GRACE methodology. REST retained for external/public APIs.
      </Rationale>
      <Links>
        <Link ref="Technology.xml#TECH-grpc" />
        <Link ref="Technology.xml#TECH-protobuf" />
      </Links>
    </Decision>

    <Decision id="DEC-CI-CD-PLATFORM" status="APPROVED">
      <Title>CI/CD Platform</Title>
      <Selected>GitHub Actions</Selected>
      <Alternatives>
        <Alternative>GitLab CI</Alternative>
        <Alternative>Jenkins</Alternative>
        <Alternative>CircleCI</Alternative>
      </Alternatives>
      <Rationale>
        GitHub Actions integrates natively with GitHub repository. Provides
        reusable workflows, matrix builds, and easy secrets management.
        Large marketplace of actions for common tasks.
      </Rationale>
      <Links>
        <Link ref="Technology.xml#TECH-github-actions" />
      </Links>
    </Decision>

    <Decision id="DEC-FEATURE-FLAGS" status="ASSUMED">
      <Title>Feature Flag System</Title>
      <Selected>Unleash</Selected>
      <Alternatives>
        <Alternative>LaunchDarkly</Alternative>
        <Alternative>Flagsmith</Alternative>
      </Alternatives>
      <Rationale>
        Unleash is open-source and self-hostable. Sufficient for initial needs;
        may migrate to managed service if scale demands.
      </Rationale>
    </Decision>

    <!-- ═══════════════════════════════════════════════════════════════════════════
         ARCHITECTURAL PATTERN DECISIONS (Promoted from Service Handoffs)
         ═══════════════════════════════════════════════════════════════════════════ -->
    <Decision id="DEC-ARCH-RULE-ENGINE-STRATEGY" status="APPROVED">
      <Title>Domain Rule Engine Strategy</Title>
      <Selected>Domain-native rule evaluation with aggregate-owned RuleSet</Selected>
      <Alternatives>
        <Alternative>External rule engine (Drools, Easy Rules)</Alternative>
        <Alternative>Configuration-driven rules in database with generic evaluator</Alternative>
      </Alternatives>
      <Rationale>
        Rules are core domain logic and should be explicit, testable, and version-controlled
        with the domain model. External engines add complexity and make rules opaque to
        domain experts. A domain-native approach keeps business rules in domain services
        without external dependencies. Complex engines (Drools) can be introduced later
        for specific high-volume rule scenarios if needed.
      </Rationale>
      <ApplicableServices>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-catalog-configuration-service">Configuration
          validation rules</ServiceRef>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-pricing-service">Campaign and discount rules</ServiceRef>
      </ApplicableServices>
      <PromotedFrom handoff="Handoff-20251230-07" originalId="DEC-CATALOG-RULE-ENGINE" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-CATALOG-CONFIGURE-ITEM" />
        <Link ref="RequirementsAnalysis.xml#UC-PRICING-QUOTE" />
      </Links>
    </Decision>

    <Decision id="DEC-ARCH-ENTITY-VERSIONING" status="APPROVED">
      <Title>Domain Entity Versioning Strategy</Title>
      <Selected>Soft-delete with versioned snapshots (Version aggregate pattern)</Selected>
      <Alternatives>
        <Alternative>Event sourcing for full history</Alternative>
        <Alternative>Temporal tables (database-level)</Alternative>
        <Alternative>No versioning (overwrite in place)</Alternative>
      </Alternatives>
      <Rationale>
        Versioned snapshots support audit trail, rollback capability, and time-travel queries
        for historical data (e.g., orders referencing catalog state at order time, pricing
        at quote time). Simpler than full event sourcing while providing sufficient history.
        Implemented via Version aggregate (CatalogVersion, PriceBookVersion) that captures
        snapshots on publish. Soft-delete prevents accidental data loss while keeping
        referential integrity for historical records.
      </Rationale>
      <ApplicableServices>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-catalog-configuration-service">CatalogVersion
          for product templates</ServiceRef>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-pricing-service">PriceBookVersion for pricing
          history</ServiceRef>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-order-service">Order snapshots (implicit, stored
          per order)</ServiceRef>
      </ApplicableServices>
      <Implementation>
        <Pattern>Version aggregate with JSONB snapshot column</Pattern>
        <SoftDelete>status column with DRAFT/ACTIVE/ARCHIVED states</SoftDelete>
        <Audit>version_number, published_at, published_by columns</Audit>
      </Implementation>
      <PromotedFrom handoff="Handoff-20251230-07" originalId="DEC-CATALOG-VERSIONING" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-CATALOG-ADMIN-MANAGE" />
        <Link ref="RequirementsAnalysis.xml#UC-PRICING-ADMIN-MANAGE" />
      </Links>
    </Decision>

    <!-- ═══════════════════════════════════════════════════════════════════════════
         PRICING SERVICE DECISIONS (Promoted from Handoff-20251231-02)
         ═══════════════════════════════════════════════════════════════════════════ -->
    <Decision id="DEC-PRICING-BASE-PRICE-FORMULA" status="APPROVED">
      <Title>Base Price Calculation Formula</Title>
      <Selected>Area-based pricing: base_price = area_m2 * price_per_m2</Selected>
      <Alternatives>
        <Alternative>Per-unit fixed pricing</Alternative>
        <Alternative>Linear dimension pricing (perimeter-based)</Alternative>
        <Alternative>Component-based pricing</Alternative>
      </Alternatives>
      <Rationale>
        Windows and doors are priced by area (m²). Price books define price_per_m2
        for each product family. This approach reflects manufacturing cost proportional
        to material usage. Minimum area thresholds ensure profitability on small items.
      </Rationale>
      <PromotedFrom handoff="Handoff-20251231-02" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-PRICING-QUOTE" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-pricing-service" />
      </Links>
    </Decision>

    <Decision id="DEC-PRICING-PREMIUM-TYPES" status="APPROVED">
      <Title>Option Premium Types</Title>
      <Selected>Two premium types: ABSOLUTE (fixed amount) and PERCENTAGE (of base price)</Selected>
      <Alternatives>
        <Alternative>Single premium type (absolute only)</Alternative>
        <Alternative>Tiered pricing by quantity</Alternative>
        <Alternative>Complex formula-based premiums</Alternative>
      </Alternatives>
      <Rationale>
        Some options (handles, locks) have fixed costs regardless of product size.
        Others (premium glazing, special lamination) scale with product area.
        Percentage premiums are calculated on base price, not running total,
        ensuring predictable pricing and avoiding compound effects.
      </Rationale>
      <PromotedFrom handoff="Handoff-20251231-02" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-PRICING-QUOTE" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-pricing-service" />
      </Links>
    </Decision>

    <Decision id="DEC-PRICING-DISCOUNT-PRECEDENCE" status="APPROVED">
      <Title>Discount Precedence and Stacking</Title>
      <Selected>Campaign discounts apply first, then promo codes. Max combined discount: 30%</Selected>
      <Alternatives>
        <Alternative>No stacking (best single discount wins)</Alternative>
        <Alternative>Unlimited stacking</Alternative>
        <Alternative>Customer-type based discount priority</Alternative>
      </Alternatives>
      <Rationale>
        Campaign discounts are business-driven (seasonal sales, clearance).
        Promo codes are customer-acquired (marketing, loyalty). Stacking allowed
        but capped at 30% to protect margins. Best discount wins within each category.
        Order of application (campaign first) ensures consistent behavior.
      </Rationale>
      <PromotedFrom handoff="Handoff-20251231-02" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-PRICING-QUOTE" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-pricing-service" />
      </Links>
    </Decision>

    <Decision id="DEC-PRICING-CURRENCY" status="APPROVED">
      <Title>Currency Support Strategy</Title>
      <Selected>Single currency (RUB) initially; multi-currency deferred to Wave 5</Selected>
      <Alternatives>
        <Alternative>Multi-currency from day one</Alternative>
        <Alternative>USD as base with conversion</Alternative>
        <Alternative>Dual currency (RUB + USD)</Alternative>
      </Alternatives>
      <Rationale>
        Per RequirementsAnalysis.xml#ASSUM-003, initial launch targets single market (Russia).
        Price books are currency-specific. Multi-currency adds exchange rate management
        complexity that can be deferred. Money value object supports currency for
        future expansion without schema changes.
      </Rationale>
      <PromotedFrom handoff="Handoff-20251231-02" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#ASSUM-003" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-pricing-service" />
      </Links>
    </Decision>

    <Decision id="DEC-PRICING-TAX-STRATEGY" status="APPROVED">
      <Title>Tax Calculation Strategy</Title>
      <Selected>Region-based VAT with Russia (20%) as default</Selected>
      <Alternatives>
        <Alternative>Flat tax rate for all regions</Alternative>
        <Alternative>External tax service integration</Alternative>
        <Alternative>No tax calculation (defer to invoicing)</Alternative>
      </Alternatives>
      <Rationale>
        Russian VAT is 20% on most goods and must be shown in quotes for transparency
        and 54-FZ compliance. Tax rules stored per region allow future expansion to
        other markets. Tax is calculated on subtotal (after discounts, before rounding).
      </Rationale>
      <PromotedFrom handoff="Handoff-20251231-02" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-PRICING-QUOTE" />
        <Link ref="Technology.xml#TECH-yookassa" />
      </Links>
    </Decision>

    <Decision id="DEC-PRICING-ROUNDING" status="APPROVED">
      <Title>Price Rounding Policy</Title>
      <Selected>HALF_UP rounding to 2 decimal places for RUB</Selected>
      <Alternatives>
        <Alternative>Truncation (floor)</Alternative>
        <Alternative>HALF_EVEN (banker's rounding)</Alternative>
        <Alternative>Ceiling (always round up)</Alternative>
      </Alternatives>
      <Rationale>
        Standard commercial rounding (HALF_UP) is customer-expected behavior.
        Applied as final step after all calculations to avoid cumulative errors.
        Different currencies may have different precision (e.g., JPY has 0 decimals)
        and the rounding service supports currency-specific configuration.
      </Rationale>
      <PromotedFrom handoff="Handoff-20251231-02" />
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-pricing-service" />
      </Links>
    </Decision>

    <Decision id="DEC-PRICING-QUOTE-TTL" status="APPROVED">
      <Title>Quote Cache TTL</Title>
      <Selected>5 minutes TTL in Redis</Selected>
      <Alternatives>
        <Alternative>No caching (recalculate every time)</Alternative>
        <Alternative>Longer TTL (15-30 minutes)</Alternative>
        <Alternative>Session-based caching only</Alternative>
      </Alternatives>
      <Rationale>
        Quotes are expensive to calculate (DB lookups, rule evaluation). 5-minute TTL
        balances freshness with performance. Quote ID + hash of inputs used as cache
        key for idempotency. Cache is invalidated on price book updates to ensure
        customers see current prices.
      </Rationale>
      <PromotedFrom handoff="Handoff-20251231-02" />
      <Links>
        <Link ref="Technology.xml#TECH-redis" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-pricing-service" />
      </Links>
    </Decision>

    <Decision id="DEC-DISTRIBUTED-LOCK" status="APPROVED">
      <Title>Distributed Lock Mechanism for Cross-Instance Coordination</Title>
      <Selected>Redis-based distributed locks with Redisson</Selected>
      <Alternatives>
        <Alternative>Database advisory locks (requires service-specific DB)</Alternative>
        <Alternative>Elasticsearch document-based locks (non-standard)</Alternative>
        <Alternative>ZooKeeper/etcd (additional infrastructure)</Alternative>
      </Alternatives>
      <Rationale>
        Redis is already in the stack (TECH-redis) for caching and rate limiting.
        Redisson provides reliable distributed locks with TTL, auto-renewal, and
        fairness options. Used by search-service for reindex coordination to prevent
        concurrent full reindex operations. Lock TTL set to 30 minutes with renewal
        to handle long-running reindex jobs safely.
      </Rationale>
      <Configuration>
        <Item>Lock provider: Redisson (RedissonClient)</Item>
        <Item>Spring Integration: spring-integration-redis DistributedLock abstraction</Item>
        <Item>Default lock TTL: 30 seconds (auto-renewed for long operations)</Item>
        <Item>Wait timeout: Configurable per use case (0 for reindex = fail-fast)</Item>
      </Configuration>
      <UseCases>
        <UseCase>FC-search-reindexCatalog: Exclusive lock for catalog reindex</UseCase>
        <UseCase>Future: Other singleton operations requiring coordination</UseCase>
      </UseCases>
      <AddedFor>ISS-SEARCH-BLUEPRINT-002</AddedFor>
      <Links>
        <Link ref="Technology.xml#TECH-redis" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-search-service" />
      </Links>
    </Decision>

    <!-- ═══════════════════════════════════════════════════════════════════════════
         CART SERVICE DECISIONS (Promoted from Handoff-20260109-01-W1-T6-CartService)
         ═══════════════════════════════════════════════════════════════════════════ -->
    <Decision id="DEC-CART-ANONYMOUS" status="APPROVED">
      <Title>Anonymous Cart Identification Strategy</Title>
      <Selected>Session-based cart ID stored in HTTP-only cookie with Redis session storage</Selected>
      <Alternatives>
        <Alternative>Redis key only (no cookie, stateless lookup by client ID)</Alternative>
        <Alternative>Database-only anonymous carts (no Redis)</Alternative>
        <Alternative>Local storage cart ID (client-generated)</Alternative>
      </Alternatives>
      <Rationale>
        HTTP-only cookie provides secure session binding. Redis session storage enables
        fast cart retrieval and automatic TTL management. Cookie name: KANOKNA_CART_SESSION.
        Server generates cart_id on first add-to-cart for anonymous users.
        Authenticated users have cart_id derived from customer_id (deterministic).
      </Rationale>
      <Configuration>
        <Item>Cookie name: KANOKNA_CART_SESSION</Item>
        <Item>Cookie attributes: HttpOnly, Secure (prod), SameSite=Lax</Item>
        <Item>Cookie max-age: 7 days (aligned with anonymous cart TTL)</Item>
        <Item>Redis key pattern: cart:session:{session_id}</Item>
        <Item>Redis key pattern (auth): cart:customer:{customer_id}</Item>
      </Configuration>
      <PromotedFrom handoff="Handoff-20260109-01-W1-T6-CartService" />
      <Links>
        <Link ref="Technology.xml#TECH-redis" />
        <Link ref="RequirementsAnalysis.xml#UC-CART-MANAGE" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-cart-service" />
      </Links>
    </Decision>

    <Decision id="DEC-CART-TTL" status="APPROVED">
      <Title>Cart Expiration Policy</Title>
      <Selected>7 days for anonymous carts; indefinite for authenticated carts</Selected>
      <Alternatives>
        <Alternative>30 days for all carts</Alternative>
        <Alternative>24 hours for anonymous, 30 days for authenticated</Alternative>
        <Alternative>No expiration (manual cleanup only)</Alternative>
      </Alternatives>
      <Rationale>
        7-day TTL for anonymous carts balances user convenience with storage efficiency.
        Authenticated carts persist indefinitely to support long sales cycles common in
        windows/doors purchases. Carts transition to ABANDONED status after inactivity
        threshold for notification-service abandoned cart reminders (separate from TTL).
      </Rationale>
      <Configuration>
        <Item>Anonymous cart TTL: 7 days (168 hours)</Item>
        <Item>Authenticated cart TTL: Indefinite (no automatic expiration)</Item>
        <Item>Abandoned cart threshold: 72 hours inactivity (for notification triggers)</Item>
        <Item>Redis TTL applied to session key for anonymous carts</Item>
        <Item>Database soft-delete for authenticated carts after 365 days inactivity</Item>
      </Configuration>
      <PromotedFrom handoff="Handoff-20260109-01-W1-T6-CartService" />
      <Links>
        <Link ref="Technology.xml#TECH-redis" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-cart-service" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-notification-service" />
      </Links>
    </Decision>

    <Decision id="DEC-CART-MERGE" status="APPROVED">
      <Title>Anonymous to Authenticated Cart Merge Strategy</Title>
      <Selected>Merge items into authenticated cart with conflict resolution (keep both, sum
        quantities)</Selected>
      <Alternatives>
        <Alternative>Replace authenticated cart with anonymous cart</Alternative>
        <Alternative>Discard anonymous cart on login</Alternative>
        <Alternative>Prompt user to choose which cart to keep</Alternative>
      </Alternatives>
      <Rationale>
        Merge strategy preserves user work from both sessions. When same product+configuration
        exists in both carts, quantities are summed. After merge, anonymous cart is deleted.
        Price quotes are refreshed during merge to ensure current pricing. Merge is triggered
        automatically on successful authentication (login/signup) when anonymous cart exists.
      </Rationale>
      <MergeRules>
        <Rule id="MERGE-001">Items with identical configuration hash are merged (quantities summed)</Rule>
        <Rule id="MERGE-002">Items with different configurations are both kept</Rule>
        <Rule id="MERGE-003">Applied promo code from authenticated cart takes precedence</Rule>
        <Rule id="MERGE-004">If no promo code on auth cart, anonymous cart promo is preserved</Rule>
        <Rule id="MERGE-005">All prices are refreshed after merge</Rule>
        <Rule id="MERGE-006">Anonymous cart is deleted after successful merge</Rule>
      </MergeRules>
      <PromotedFrom handoff="Handoff-20260109-01-W1-T6-CartService" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-CART-MANAGE" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-cart-service" />
      </Links>
    </Decision>

    <Decision id="DEC-CART-PRICE-LOCK" status="APPROVED">
      <Title>Quote Validity and Price Lock Strategy</Title>
      <Selected>Prices cached per item with 5-minute quote TTL; warn on stale, auto-refresh on
        checkout</Selected>
      <Alternatives>
        <Alternative>Always fetch fresh prices (no caching)</Alternative>
        <Alternative>Lock prices at add-to-cart time until checkout</Alternative>
        <Alternative>Lock prices for 24 hours</Alternative>
      </Alternatives>
      <Rationale>
        Cart items store quote_id from pricing-service with 5-minute TTL (per
        DEC-PRICING-QUOTE-TTL).
        On GetCart, system checks quote validity. If stale, items marked as price_stale=true.
        Frontend displays staleness warning. CreateSnapshot always refreshes all prices
        to ensure checkout uses current pricing. Customer must acknowledge price changes
        before checkout proceeds.
      </Rationale>
      <Configuration>
        <Item>Quote TTL: 5 minutes (from pricing-service cache)</Item>
        <Item>Staleness check: Compare quote valid_until with current time</Item>
        <Item>Auto-refresh: On CreateSnapshot (checkout)</Item>
        <Item>User notification: Frontend shows "Prices may have changed" badge</Item>
        <Item>Price change acknowledgement required if total differs > 1%</Item>
      </Configuration>
      <PromotedFrom handoff="Handoff-20260109-01-W1-T6-CartService" />
      <Links>
        <Link ref="Technology.xml#DEC-PRICING-QUOTE-TTL" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-pricing-service" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-cart-service" />
      </Links>
    </Decision>

    <Decision id="DEC-CART-STATE-MACHINE" status="APPROVED">
      <Title>Cart State Lifecycle</Title>
      <Selected>Four states: ACTIVE, CHECKED_OUT, ABANDONED, MERGED</Selected>
      <Alternatives>
        <Alternative>Only ACTIVE state (no state machine)</Alternative>
        <Alternative>ACTIVE, LOCKED, COMPLETED states</Alternative>
      </Alternatives>
      <Rationale>
        Cart state machine tracks lifecycle for analytics and operations:
        - ACTIVE: Default state, accepts modifications
        - CHECKED_OUT: Snapshot created, cart cleared, items moved to order
        - ABANDONED: Inactivity threshold exceeded (notification trigger)
        - MERGED: Anonymous cart merged into authenticated (terminal, soft-deleted)
        State changes are audited for analytics (abandoned cart rate, checkout conversion).
      </Rationale>
      <StateMachine>
        <State name="ACTIVE" initial="true">Cart accepts modifications</State>
        <State name="CHECKED_OUT" terminal="true">Snapshot created for order</State>
        <State name="ABANDONED">Inactive past threshold (notification trigger)</State>
        <State name="MERGED" terminal="true">Anonymous cart merged</State>
        <Transition from="ACTIVE" to="CHECKED_OUT" event="SNAPSHOT_CREATED" />
        <Transition from="ACTIVE" to="ABANDONED" event="INACTIVITY_THRESHOLD" />
        <Transition from="ABANDONED" to="ACTIVE" event="CART_MODIFIED" />
        <Transition from="ACTIVE" to="MERGED" event="CART_MERGED" />
        <Transition from="ABANDONED" to="MERGED" event="CART_MERGED" />
      </StateMachine>
      <PromotedFrom handoff="Handoff-20260109-01-W1-T6-CartService" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-CART-MANAGE" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-cart-service" />
      </Links>
    </Decision>

    <Decision id="DEC-CART-VALIDATION" status="APPROVED">
      <Title>Configuration Revalidation Strategy</Title>
      <Selected>Validate on add-to-cart and on GetCart (lazy revalidation)</Selected>
      <Alternatives>
        <Alternative>Validate only on add-to-cart</Alternative>
        <Alternative>Validate only on checkout</Alternative>
        <Alternative>No revalidation (trust stored configuration)</Alternative>
      </Alternatives>
      <Rationale>
        Product configurations may become invalid if catalog rules change after item was added.
        On GetCart, cart-service calls catalog-configuration-service.ValidateConfiguration for
        each item and marks items as validation_status=VALID|INVALID|UNKNOWN.
        Invalid items display warning; customer can reconfigure or remove.
        CreateSnapshot fails if any item is INVALID (customer must resolve first).
      </Rationale>
      <ValidationBehavior>
        <Item>Add-to-cart: Full validation required (reject invalid configurations)</Item>
        <Item>GetCart: Lazy revalidation with status flag (allow display of invalid items)</Item>
        <Item>CreateSnapshot: Full validation required (reject if any item invalid)</Item>
        <Item>Validation timeout: 2 seconds (use last known status on timeout)</Item>
      </ValidationBehavior>
      <PromotedFrom handoff="Handoff-20260109-01-W1-T6-CartService" />
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-catalog-configuration-service" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-cart-service" />
      </Links>
    </Decision>

    <!-- ═══════════════════════════════════════════════════════════════════════════
         DOMAIN ERROR HANDLING DECISIONS (From Handoff-20260117-01-W1-ERROR-HANDLING)
         ═══════════════════════════════════════════════════════════════════════════ -->
    <Decision id="DEC-DOMAIN-ERROR-PATTERN" status="APPROVED">
      <Title>Domain Error Handling Pattern</Title>
      <Selected>Static factory class with typed DomainException per service</Selected>
      <Alternatives>
        <Alternative>Throw IllegalArgumentException directly</Alternative>
        <Alternative>Domain-specific exception hierarchy per error type</Alternative>
        <Alternative>Result/Either type for all domain operations</Alternative>
      </Alternatives>
      <Rationale>
        Static factory pattern (AccountDomainErrors, CartDomainErrors) centralizes error creation,
        ensures consistent error codes, enables code completion, and keeps domain layer clean.
        DomainException from shared-kernel provides base class with code+message+optional cause.
        Typed subclasses (e.g., CartNotFoundException) used only when polymorphic handling needed.
      </Rationale>
      <Convention>
        <Item>Factory class: {BoundedContext}DomainErrors in com.kanokna.{service}.domain.exception</Item>
        <Item>Error code format: ERR-{PREFIX}-{ERROR-TYPE}</Item>
        <Item>Prefixes: ACCT (account), CART (cart), CAT (catalog), PRICE (pricing), SEARCH (search)</Item>
        <Item>Factory methods are static, return DomainException or typed subclass</Item>
        <Item>Factory class has private constructor, marked final</Item>
        <Item>Error messages include relevant context (IDs, values) for debugging</Item>
      </Convention>
      <ApplicableServices>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-account-service">AccountDomainErrors (implemented)</ServiceRef>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-cart-service">CartDomainErrors (implemented)</ServiceRef>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-catalog-configuration-service">CatalogDomainErrors</ServiceRef>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-pricing-service">PricingDomainErrors</ServiceRef>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-order-service">OrderDomainErrors (future)</ServiceRef>
      </ApplicableServices>
      <PromotedFrom handoff="Handoff-20260117-01-W1-ERROR-HANDLING" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-CODE-DOMAIN-ERROR-HANDLING" />
      </Links>
    </Decision>

    <Decision id="DEC-ERROR-CODE-REGISTRY" status="APPROVED">
      <Title>Service Error Code Prefix Registry</Title>
      <Selected>Centralized prefix registry to prevent collisions</Selected>
      <Registry>
        <Prefix code="ERR-ACCT" service="account-service">Account domain errors</Prefix>
        <Prefix code="ERR-CART" service="cart-service">Cart domain errors</Prefix>
        <Prefix code="ERR-CAT" service="catalog-configuration-service">Catalog domain errors</Prefix>
        <Prefix code="ERR-PRICE" service="pricing-service">Pricing domain errors</Prefix>
        <Prefix code="ERR-SEARCH" service="search-service" status="reserved">Search domain errors</Prefix>
        <Prefix code="ERR-ORDER" service="order-service" status="reserved">Order domain errors</Prefix>
        <Prefix code="ERR-MEDIA" service="media-service" status="reserved">Media domain errors</Prefix>
        <Prefix code="ERR-NOTIF" service="notification-service" status="reserved">Notification errors</Prefix>
      </Registry>
      <Rationale>
        Unique prefixes per service enable log aggregation, error categorization in monitoring,
        and clear ownership of error codes. Reserved prefixes prevent future conflicts.
      </Rationale>
      <PromotedFrom handoff="Handoff-20260117-01-W1-ERROR-HANDLING" />
      <Links>
        <Link ref="Technology.xml#DEC-DOMAIN-ERROR-PATTERN" />
      </Links>
    </Decision>

    <Decision id="DEC-PACKAGE-NAMING-CONVENTION" status="APPROVED">
      <Title>Java Package Naming Convention</Title>
      <Context>Need consistent package naming across all services for maintainability and IDE navigation</Context>
      <Selected>Package root follows bounded context name: com.kanokna.{bounded-context}.*</Selected>
      <Convention>
        <Item>Package root: com.kanokna.{bounded-context}.*</Item>
        <Item>Bounded context name uses lowercase, NO underscores</Item>
        <Item>Service name may differ from bounded context (e.g., catalog-configuration-service uses com.kanokna.catalog)</Item>
      </Convention>
      <Registry>
        <Service name="account-service" package="com.kanokna.account" />
        <Service name="cart-service" package="com.kanokna.cart" />
        <Service name="catalog-configuration-service" package="com.kanokna.catalog" />
        <Service name="pricing-service" package="com.kanokna.pricing" />
        <Service name="search-service" package="com.kanokna.search" />
        <Service name="order-service" package="com.kanokna.order" />
        <Service name="media-service" package="com.kanokna.media" />
        <Service name="notification-service" package="com.kanokna.notification" />
        <Service name="installation-service" package="com.kanokna.installation" />
        <Service name="reporting-service" package="com.kanokna.reporting" />
      </Registry>
      <Rationale>
        Bounded context names are stable domain concepts; service names may change.
        No underscores in package names follows Java conventions (JLS §6.1).
      </Rationale>
      <PromotedFrom handoff="Handoff-20260117-02-W1-PKG-RENAME" />
    </Decision>

    <Decision id="DEC-SRP-DECOMPOSITION-STRATEGY" status="APPROVED">
      <Title>Application Service Decomposition Strategy</Title>
      <Context>Large application service classes (>500 lines or >3 use case groups) should be decomposed for maintainability</Context>
      <Selected>Delegate Pattern - main service implements interfaces, delegates to specialized services</Selected>
      <Pattern>
        <Item>Main service (e.g., AccountApplicationService) remains as facade implementing use case interfaces</Item>
        <Item>Specialized services (e.g., ProfileService, AddressService) contain actual business logic</Item>
        <Item>Shared dependencies (repositories, validators) injected into both main and specialized services</Item>
        <Item>Transaction boundaries managed by main service @Transactional annotation</Item>
      </Pattern>
      <Benefits>
        <Item>Maintains API compatibility (existing interfaces unchanged)</Item>
        <Item>Each specialized service has single responsibility</Item>
        <Item>Easier unit testing of individual components</Item>
        <Item>Gradual migration possible</Item>
      </Benefits>
      <Threshold>
        <Item>Decompose when: >500 lines of actual code (excluding comments)</Item>
        <Item>Decompose when: >3 distinct use case groups with separate repositories</Item>
        <Item>Keep when: Operations are cohesive and share state</Item>
      </Threshold>
      <Links>
        <Link ref="DEC-ACCOUNT-DECOMPOSITION" />
        <Link ref="DEC-CART-DECOMPOSITION" />
        <Link ref="DEC-SEARCH-DECOMPOSITION" />
      </Links>
    </Decision>

    <Decision id="DEC-ACCOUNT-DECOMPOSITION" status="APPROVED">
      <Title>AccountApplicationService Decomposition</Title>
      <Context>AccountApplicationService (964 lines) has 4 use case groups with distinct repositories</Context>
      <Selected>DECOMPOSE into 3 specialized services + facade</Selected>
      <Decomposition>
        <FacadeService name="AccountApplicationService">
          <Role>Implements use case interfaces, delegates to specialized services</Role>
          <Interfaces>GetProfileUseCase, UpdateProfileUseCase, AddressManagementUseCase, ConfigurationManagementUseCase</Interfaces>
        </FacadeService>
        <SpecializedService name="ProfileService">
          <Package>com.kanokna.account.application.service</Package>
          <Responsibility>User profile CRUD operations</Responsibility>
          <Methods>getProfile, updateProfile, createProfileFromKeycloak</Methods>
          <Dependencies>UserProfileRepository, EventPublisher, CurrentUserProvider, AccountProperties</Dependencies>
        </SpecializedService>
        <SpecializedService name="AddressService">
          <Package>com.kanokna.account.application.service</Package>
          <Responsibility>Address management operations</Responsibility>
          <Methods>addAddress, updateAddress, deleteAddress, listAddresses</Methods>
          <Dependencies>SavedAddressRepository, UserProfileRepository, EventPublisher, CurrentUserProvider</Dependencies>
        </SpecializedService>
        <SpecializedService name="SavedConfigurationService">
          <Package>com.kanokna.account.application.service</Package>
          <Responsibility>Saved product configuration management</Responsibility>
          <Methods>saveConfiguration, listConfigurations, deleteConfiguration</Methods>
          <Dependencies>SavedConfigurationRepository, EventPublisher, CurrentUserProvider, ConfigurationSnapshotValidator</Dependencies>
        </SpecializedService>
      </Decomposition>
      <TransactionStrategy>
        <Item>Each specialized service method is transactional via @Transactional</Item>
        <Item>Facade delegates directly - no additional transaction wrapping needed</Item>
      </TransactionStrategy>
      <Rationale>
        Each group uses distinct repository (except Address needs UserProfile for loading).
        Clear separation of concerns improves testability and maintainability.
      </Rationale>
      <PromotedFrom handoff="Handoff-20260117-03-W1-SRP-DECOMPOSITION" />
    </Decision>

    <Decision id="DEC-CART-DECOMPOSITION" status="APPROVED">
      <Title>CartApplicationService Decomposition</Title>
      <Context>CartApplicationService (461 lines) reviewed for SRP compliance</Context>
      <Selected>KEEP - already well-structured with helper services</Selected>
      <ExistingStructure>
        <HelperService name="CartItemValidationService">Item validation logic</HelperService>
        <HelperService name="CartPricingService">Price calculation and refresh</HelperService>
        <HelperService name="CartMergingService">Anonymous to authenticated cart merge</HelperService>
        <HelperService name="CartCheckoutService">Checkout snapshot generation</HelperService>
        <HelperService name="CartPromoCodeService">Promo code application</HelperService>
        <HelperService name="CartDtoMapper">DTO mapping utilities</HelperService>
      </ExistingStructure>
      <Rationale>Cart-service already follows the decomposition pattern; no further action needed</Rationale>
    </Decision>

    <Decision id="DEC-SEARCH-DECOMPOSITION" status="APPROVED">
      <Title>SearchApplicationService Decomposition</Title>
      <Context>SearchApplicationService (1095 lines) reviewed for SRP compliance</Context>
      <Selected>KEEP - operations are cohesive around search domain</Selected>
      <Analysis>
        <UseCaseGroup name="Query" methods="searchProducts, autocomplete, getFacetValues, getProductById">Read-only operations</UseCaseGroup>
        <UseCaseGroup name="IndexManagement" methods="indexProduct, deleteProduct, reindexCatalog">Write operations</UseCaseGroup>
      </Analysis>
      <Rationale>
        All operations share SearchRepository and are cohesive around the search bounded context.
        Query and Index operations are complementary, not independent responsibilities.
        Future consideration: extract SearchIndexManagementService if complexity grows.
      </Rationale>
      <FutureConsideration>
        If reindexCatalog grows more complex or index management gets additional operations,
        consider extracting SearchIndexManagementService.
      </FutureConsideration>
    </Decision>
  </Decisions>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       ASSUMPTIONS
       ═══════════════════════════════════════════════════════════════════════════ -->
  <Assumptions>
    <Assumption id="TECH-ASSUM-001">
      Spring Boot 4.0.0 version in POM is a placeholder; actual APIs may differ from current 3.x.
      Implementation must verify compatibility when 4.x is released.
    </Assumption>
    <Assumption id="TECH-ASSUM-002">
      Object storage provider decision (MinIO vs S3) deferred to deployment configuration.
      API is S3-compatible in either case.
    </Assumption>
  </Assumptions>

</Technology>