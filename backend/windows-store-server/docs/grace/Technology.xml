<?xml version="1.0" encoding="UTF-8"?>
<!--
  GRACE Canonical Artifact: Technology.xml
  Purpose: Define approved technology stack, versions, and cross-cutting technical decisions
  Version: 1.5.1
  Last Updated: 2026-01-27T12:41:00+03:00
  Changes: v1.5.1 - Updated TECH-elasticsearch to 8.17.1, TC-ELASTICSEARCH to 8.17.1.
                    Kept TECH-testcontainers at 1.20.x. Updated DEC-ES-VERSION-UPGRADE
                    to reflect 8.17.1 decision per user request.
           v1.4.0 - Added DEC-CART-* decisions from Handoff-20260109-01-W1-T6-CartService
           v1.3.0 - Added DEC-DISTRIBUTED-LOCK for search-service reindex (ISS-SEARCH-BLUEPRINT-002)
           v1.2.0 - Added DEC-PRICING-* decisions from Handoff-20251231-02
           v1.1.0 - Promoted DEC-CATALOG-RULE-ENGINE and DEC-CATALOG-VERSIONING from Handoff-20251230-07
           as architectural patterns DEC-ARCH-RULE-ENGINE-STRATEGY and DEC-ARCH-ENTITY-VERSIONING
-->
<Technology version="1.5.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

  <!-- ═══════════════════════════════════════════════════════════════════════════
       LANGUAGES
       ═══════════════════════════════════════════════════════════════════════════ -->
  <Languages>
    <Language id="TECH-java">
      <Name>Java</Name>
      <Version>25</Version>
      <Usage>Primary backend language for all services</Usage>
      <Notes>
        Using latest LTS features: records, sealed classes, pattern matching, virtual threads.
        Preview features enabled selectively in dev profile only.
      </Notes>
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-shared-kernel" />
      </Links>
    </Language>
  </Languages>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       FRAMEWORKS
       ═══════════════════════════════════════════════════════════════════════════ -->
  <Frameworks>
    <Framework id="TECH-spring-boot">
      <Name>Spring Boot</Name>
      <Version status="TBD">4.0.0</Version>
      <Usage>Foundation for all microservices</Usage>
      <Notes>
        Spring Boot 4.0.0 is declared in parent POM. version placeholder retained from project POM.
        Implementation should verify API compatibility when actual release is available.
      </Notes>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-MAINT-MODULARITY" />
      </Links>
    </Framework>

    <Framework id="TECH-spring-cloud">
      <Name>Spring Cloud</Name>
      <Version>2024.0.0</Version>
      <Usage>Service discovery, configuration, resilience patterns</Usage>
      <Components>
        <Component name="spring-cloud-config">Centralized configuration (config-server)</Component>
        <Component name="spring-cloud-gateway">API Gateway routing and filtering</Component>
        <Component name="spring-cloud-circuitbreaker">Circuit breaker abstraction</Component>
      </Components>
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-config-server" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-gateway" />
      </Links>
    </Framework>

    <Framework id="TECH-grpc">
      <Name>gRPC</Name>
      <Version>1.60.x</Version>
      <Usage>Synchronous inter-service communication</Usage>
      <Components>
        <Component name="grpc-spring-boot-starter">gRPC server and client integration</Component>
        <Component name="protobuf-java">Protocol Buffers runtime</Component>
        <Component name="grpc-netty-shaded">Netty transport</Component>
      </Components>
      <Configuration>
        <Item>Service definitions in api-contracts module (.proto files)</Item>
        <Item>Generated stubs used in adapters.out.grpc packages</Item>
        <Item>Deadline propagation for timeout management</Item>
        <Item>Interceptors for tracing and authentication</Item>
        <Item>Health checks via gRPC Health Checking Protocol</Item>
      </Configuration>
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-api-contracts" />
        <Link ref="Technology.xml#TECH-protobuf" />
      </Links>
    </Framework>

    <Framework id="TECH-spring-security">
      <Name>Spring Security</Name>
      <Version>Managed by Spring Boot BOM</Version>
      <Usage>Authentication, authorization, OAuth2 resource server</Usage>
      <Configuration>
        <Item>All services act as OAuth2 Resource Servers validating JWT tokens</Item>
        <Item>Gateway performs initial authentication; services re-validate</Item>
        <Item>Method-level security with @PreAuthorize for role-based access</Item>
      </Configuration>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-SEC-AUTHENTICATION" />
        <Link ref="RequirementsAnalysis.xml#NFR-SEC-RBAC" />
      </Links>
    </Framework>

    <Framework id="TECH-spring-data-jpa">
      <Name>Spring Data JPA</Name>
      <Version>Managed by Spring Boot BOM</Version>
      <Usage>Repository abstraction for relational data access</Usage>
      <Configuration>
        <Item>Custom repository implementations for complex queries</Item>
        <Item>Projections for read-optimized queries</Item>
        <Item>Auditing enabled for created/modified timestamps</Item>
      </Configuration>
      <Links>
        <Link ref="Technology.xml#TECH-hibernate-jpa" />
      </Links>
    </Framework>

    <Framework id="TECH-hibernate-jpa">
      <Name>Hibernate ORM</Name>
      <Version>Managed by Spring Boot BOM</Version>
      <Usage>JPA implementation</Usage>
      <Configuration>
        <Item>ddl-auto=validate in all profiles (Flyway handles migrations)</Item>
        <Item>Open-session-in-view disabled</Item>
        <Item>Batch fetching enabled (default_batch_fetch_size=25)</Item>
        <Item>Second-level cache disabled initially; enable per-entity as needed</Item>
      </Configuration>
      <Guidelines>
        <Item>Use JPA API primarily; Hibernate extensions only when necessary</Item>
        <Item>Entities have no-arg constructor; LAZY associations not final</Item>
        <Item>equals/hashCode by business key, not DB id</Item>
        <Item>Avoid N+1: use @EntityGraph, JOIN FETCH, or batch fetching</Item>
      </Guidelines>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-MAINT-MODULARITY" />
      </Links>
    </Framework>

    <Framework id="TECH-jakarta-validation">
      <Name>Jakarta Bean Validation</Name>
      <Version>3.1</Version>
      <Usage>Input validation in adapters and application DTOs</Usage>
      <Configuration>
        <Item>Validation at REST controller boundaries (@Valid)</Item>
        <Item>Custom validators for domain-specific rules</Item>
        <Item>Domain invariants enforced in domain layer (not via annotations)</Item>
      </Configuration>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-SEC-INPUT-VALIDATION" />
      </Links>
    </Framework>

    <Framework id="TECH-mapstruct">
      <Name>MapStruct</Name>
      <Version>1.5.5.Final</Version>
      <Usage>Type-safe mapping between layers (DTO to domain, entity to domain)</Usage>
      <Configuration>
        <Item>Mappers in adapter layer only</Item>
        <Item>ComponentModel = spring for dependency injection</Item>
      </Configuration>
    </Framework>
  </Frameworks>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       INFRASTRUCTURE
       ═══════════════════════════════════════════════════════════════════════════ -->
  <Infrastructure>
    <!-- Databases -->
    <Database id="TECH-postgresql">
      <Name>PostgreSQL</Name>
      <Version>16</Version>
      <Usage>Primary OLTP database for all services</Usage>
      <Configuration>
        <Item>Each service has its own database (logical or physical)</Item>
        <Item>Connection pooling via HikariCP (default Spring Boot pool)</Item>
        <Item>Schema migrations via Flyway</Item>
      </Configuration>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-SCALE-DB-PER-SERVICE" />
      </Links>
    </Database>

    <Database id="TECH-flyway">
      <Name>Flyway</Name>
      <Version>10.x</Version>
      <Usage>Database schema migrations</Usage>
      <Configuration>
        <Item>Migration scripts in src/main/resources/db/migration</Item>
        <Item>Versioned migrations (V1__, V2__, ...)</Item>
        <Item>Repeatable migrations for views/functions (R__)</Item>
        <Item>Baseline on existing databases if needed</Item>
      </Configuration>
    </Database>

    <!-- Search -->
    <SearchEngine id="TECH-elasticsearch">
      <Name>Elasticsearch</Name>
      <Version>8.17.1</Version>
      <Usage>Full-text search, faceted filtering, autocomplete for products</Usage>
      <Configuration>
        <Item>Dedicated search-service manages indices</Item>
        <Item>Async indexing triggered by domain events from catalog-configuration-service</Item>
        <Item>Index aliases for zero-downtime reindexing</Item>
      </Configuration>
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-search-service" />
        <Link ref="RequirementsAnalysis.xml#NFR-PERF-SEARCH-LATENCY" />
      </Links>
    </SearchEngine>

    <!-- Messaging -->
    <MessageBroker id="TECH-kafka">
      <Name>Apache Kafka</Name>
      <Version>3.7.x</Version>
      <Usage>Asynchronous event-driven communication between services</Usage>
      <Configuration>
        <Item>Topics per domain event type (e.g., order.created, order.shipped)</Item>
        <Item>Consumer groups per consuming service</Item>
        <Item>Outbox pattern for reliable event publishing</Item>
        <Item>Idempotent consumers with message ID deduplication</Item>
        <Item>Schema Registry for Protobuf schema management</Item>
      </Configuration>
      <Topics>
        <Topic name="catalog.product.published">Product catalog updates</Topic>
        <Topic name="order.created">New order events</Topic>
        <Topic name="order.status.changed">Order status transitions</Topic>
        <Topic name="payment.captured">Payment capture confirmations</Topic>
        <Topic name="installation.scheduled">Installation appointment events</Topic>
      </Topics>
      <Links>
        <Link ref="DevelopmentPlan.xml#Flow-Event-Driven" />
      </Links>
    </MessageBroker>

    <!-- Caching -->
    <Cache id="TECH-redis">
      <Name>Redis</Name>
      <Version>7.x</Version>
      <Usage>Caching, session storage, rate limiting</Usage>
      <Configuration>
        <Item>Price quote caching (TTL: 5 minutes)</Item>
        <Item>Session data for anonymous carts</Item>
        <Item>Distributed rate limiting counters</Item>
        <Item>Jackson serializer for cache values</Item>
      </Configuration>
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-pricing-service" />
      </Links>
    </Cache>

    <!-- Object Storage -->
    <ObjectStorage id="TECH-s3-compatible">
      <Name>S3-Compatible Object Storage</Name>
      <Provider status="ASSUMED">MinIO (dev/stage), AWS S3 (prod)</Provider>
      <Usage>Product images, renders, installation manuals, user uploads</Usage>
      <Configuration>
        <Item>media-service manages metadata; objects stored in S3</Item>
        <Item>Presigned URLs for direct browser upload/download</Item>
        <Item>Image variants generated on upload (thumbnail, web, original)</Item>
        <Item>CDN (CloudFront) in front for production</Item>
      </Configuration>
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-media-service" />
        <Link ref="RequirementsAnalysis.xml#UC-MEDIA-SERVE" />
      </Links>
    </ObjectStorage>
  </Infrastructure>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       CROSS-CUTTING CONCERNS
       ═══════════════════════════════════════════════════════════════════════════ -->
  <CrossCutting>
    <!-- Security -->
    <Security id="TECH-security-stack">
      <IdentityProvider id="TECH-identity-provider">
        <Name>OAuth2/OIDC Identity Provider</Name>
        <Environments>
          <Environment name="dev-stage" id="TECH-keycloak">
            <Provider>Keycloak</Provider>
            <Version>24.x</Version>
            <Usage>Self-hosted OIDC for development and staging</Usage>
            <Configuration>
              <Item>Realm: kanokna</Item>
              <Item>Clients: web-frontend, mobile-app, admin-console</Item>
              <Item>Roles: CUSTOMER, INSTALLER, ADMIN, PRICING_ADMIN, CATALOG_ADMIN,
                REPORTING_VIEWER</Item>
              <Item>JWT tokens with RS256 signing</Item>
              <Item>Deployed via Docker Compose (dev) or Helm (stage)</Item>
            </Configuration>
          </Environment>
          <Environment name="prod" id="TECH-auth0">
            <Provider>Auth0</Provider>
            <Usage>Managed OIDC for production (reduced operational burden)</Usage>
            <Configuration>
              <Item>Tenant: kanokna-prod</Item>
              <Item>Applications: web-frontend, mobile-app, admin-console</Item>
              <Item>Roles mapped to JWT claims</Item>
              <Item>Social login support (Google, Facebook) if needed</Item>
              <Item>MFA enforcement for admin roles</Item>
              <Item>Branding customization for login pages</Item>
            </Configuration>
          </Environment>
        </Environments>
        <CommonConfiguration>
          <Item>All services validate JWT tokens as OAuth2 Resource Servers</Item>
          <Item>Token issuer URL configured per environment</Item>
          <Item>JWKS endpoint for public key retrieval</Item>
          <Item>Standard claims: sub, email, roles, permissions</Item>
        </CommonConfiguration>
        <Links>
          <Link ref="RequirementsAnalysis.xml#ACT-IDENTITY-PROVIDER" />
          <Link ref="RequirementsAnalysis.xml#NFR-SEC-AUTHENTICATION" />
        </Links>
      </IdentityProvider>

      <PaymentIntegration id="TECH-payment-integration">
        <Provider id="TECH-yookassa" status="APPROVED">YooKassa (YooMoney)</Provider>
        <Usage>Payment processing, authorization, capture, refunds for Russian market</Usage>
        <Configuration>
          <Item>YooKassa Java SDK for payment creation and management</Item>
          <Item>Support for bank cards (Visa, Mastercard, Mir)</Item>
          <Item>Support for YooMoney wallet payments</Item>
          <Item>Support for SberPay, Tinkoff Pay, and other Russian payment methods</Item>
          <Item>Webhooks for async payment status updates (payment.succeeded, payment.canceled,
            refund.succeeded)</Item>
          <Item>Two-stage payments: authorize then capture (for orders with production lead time)</Item>
          <Item>Receipts generation for Russian Federal Tax Service (54-FZ compliance)</Item>
          <Item>PCI-DSS compliance via tokenization (no card data stored)</Item>
          <Item>Idempotency keys for safe retries</Item>
        </Configuration>
        <Credentials>
          <Item>Shop ID and Secret Key stored in Vault/K8s Secrets</Item>
          <Item>Separate credentials per environment (test/prod)</Item>
        </Credentials>
        <Links>
          <Link ref="RequirementsAnalysis.xml#ACT-PAYMENT-GATEWAY" />
          <Link ref="DevelopmentPlan.xml#DP-SVC-order-service" />
        </Links>
      </PaymentIntegration>

      <SecretsManagement>
        <Tool>Kubernetes Secrets (dev/stage), HashiCorp Vault (prod)</Tool>
        <Policy>No secrets in source code; inject via environment or volume mounts</Policy>
      </SecretsManagement>
    </Security>

    <!-- Observability -->
    <Observability id="TECH-observability-stack">
      <Logging id="TECH-logging">
        <Format>JSON (Logstash encoder)</Format>
        <Library>logstash-logback-encoder 7.4</Library>
        <Configuration>
          <Item>Structured fields: traceId, spanId, correlationId, service, level, message</Item>
          <Item>MDC propagation for request context</Item>
          <Item>Log aggregation: ELK stack or Grafana Loki</Item>
        </Configuration>
        <Links>
          <Link ref="RequirementsAnalysis.xml#NFR-OBS-LOGGING" />
        </Links>
      </Logging>

      <Metrics id="TECH-micrometer">
        <Name>Micrometer</Name>
        <Version>Managed by Spring Boot BOM</Version>
        <Backend id="TECH-prometheus">
          <Name>Prometheus</Name>
          <Version>2.x</Version>
        </Backend>
        <Dashboards id="TECH-grafana">
          <Name>Grafana</Name>
          <Version>10.x</Version>
        </Dashboards>
        <Configuration>
          <Item>Spring Boot Actuator metrics exposed on /actuator/prometheus</Item>
          <Item>Custom business metrics via MeterRegistry</Item>
          <Item>Grafana dashboards for service health, latency, throughput</Item>
        </Configuration>
        <Links>
          <Link ref="RequirementsAnalysis.xml#NFR-OBS-METRICS" />
        </Links>
      </Metrics>

      <Tracing id="TECH-opentelemetry">
        <Name>OpenTelemetry</Name>
        <Version>1.x</Version>
        <Configuration>
          <Item>Auto-instrumentation via spring-boot-starter-actuator + micrometer-tracing</Item>
          <Item>Trace context propagation via W3C Trace Context headers</Item>
          <Item>Export to Jaeger or Tempo</Item>
        </Configuration>
        <Links>
          <Link ref="RequirementsAnalysis.xml#NFR-OBS-TRACING" />
        </Links>
      </Tracing>
    </Observability>

    <!-- Resilience -->
    <Resilience id="TECH-resilience4j">
      <Name>Resilience4j</Name>
      <Version>2.x</Version>
      <Usage>Circuit breakers, retries, timeouts, bulkheads, rate limiters</Usage>
      <Configuration>
        <Item>Circuit breaker on external service calls (payment gateway, notification providers)</Item>
        <Item>Retry with exponential backoff + jitter for transient failures</Item>
        <Item>Timeouts on all inter-service calls (default: 3s)</Item>
        <Item>Bulkhead isolation for critical paths</Item>
      </Configuration>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-AVAIL-GRACEFUL-DEGRADATION" />
      </Links>
    </Resilience>

    <!-- Feature Flags -->
    <FeatureFlags id="TECH-unleash">
      <Name>Unleash</Name>
      <Version status="ASSUMED">5.x</Version>
      <Usage>Feature toggles for gradual rollouts and A/B testing</Usage>
      <Configuration>
        <Item>SDK integrated in each service</Item>
        <Item>Flags for new features, pricing experiments, UI variations</Item>
      </Configuration>
    </FeatureFlags>

    <!-- API Documentation -->
    <ApiDocumentation id="TECH-springdoc">
      <Name>SpringDoc OpenAPI</Name>
      <Version status="TBD">2.x</Version>
      <Usage>Auto-generated OpenAPI specs and Swagger UI</Usage>
      <Configuration>
        <Item>OpenAPI 3.1 specs generated from controllers</Item>
        <Item>Swagger UI at /swagger-ui.html (dev/stage only)</Item>
        <Item>Contract-first: specs stored in docs/api-contracts/openapi</Item>
      </Configuration>
    </ApiDocumentation>
  </CrossCutting>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       SERIALIZATION
       ═══════════════════════════════════════════════════════════════════════════ -->
  <Serialization>
    <Format id="TECH-json-jackson">
      <Name>JSON (Jackson)</Name>
      <Usage>REST API request/response serialization</Usage>
      <Configuration>
        <Item>Java 8 date/time module enabled</Item>
        <Item>Fail on unknown properties: false</Item>
        <Item>Property naming: SNAKE_CASE for API, camelCase internally</Item>
      </Configuration>
    </Format>

    <Format id="TECH-protobuf">
      <Name>Protocol Buffers</Name>
      <Version>3.x</Version>
      <Usage>Kafka event serialization and gRPC inter-service communication</Usage>
      <Configuration>
        <Item>Service definitions (.proto) stored in api-contracts module</Item>
        <Item>Event schemas stored in docs/api-contracts/protobuf</Item>
        <Item>Schema Registry for versioning and compatibility checks</Item>
        <Item>Backward-compatible evolution: add optional fields, never remove/rename</Item>
        <Item>Generated Java classes via protobuf-maven-plugin</Item>
        <Item>gRPC stubs generated alongside message classes</Item>
      </Configuration>
      <ProtoStructure>
        <Directory>api-contracts/src/main/proto/</Directory>
        <Package pattern="com.kanokna.{service}.grpc">gRPC service definitions</Package>
        <Package pattern="com.kanokna.{service}.event">Domain event schemas</Package>
      </ProtoStructure>
      <Links>
        <Link ref="DevelopmentPlan.xml#ContractEvolutionPolicy" />
        <Link ref="Technology.xml#TECH-grpc" />
      </Links>
    </Format>
  </Serialization>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       BUILD & DEPLOYMENT
       ═══════════════════════════════════════════════════════════════════════════ -->
  <BuildAndDeployment>
    <Build id="TECH-maven">
      <Name>Apache Maven</Name>
      <Version>3.9.x</Version>
      <Configuration>
        <Item>Multi-module project with parent POM</Item>
        <Item>Profiles: dev, stage, prod</Item>
        <Item>Plugin management centralized in parent</Item>
      </Configuration>
    </Build>

    <ContainerImage id="TECH-jib">
      <Name>Jib</Name>
      <Usage>Build OCI container images without Dockerfile</Usage>
      <Configuration>
        <Item>Base image: eclipse-temurin:25-jre</Item>
        <Item>Layered image for efficient caching</Item>
        <Item>Push to container registry on CI</Item>
      </Configuration>
    </ContainerImage>

    <Orchestration id="TECH-kubernetes">
      <Name>Kubernetes</Name>
      <Version>1.29+</Version>
      <Configuration>
        <Item>Helm charts for each service</Item>
        <Item>ConfigMaps for non-sensitive configuration</Item>
        <Item>Secrets for credentials</Item>
        <Item>HPA for horizontal scaling</Item>
        <Item>Readiness/liveness probes via Actuator health endpoints</Item>
      </Configuration>
    </Orchestration>

    <CI id="TECH-ci-pipeline">
      <Tool id="TECH-github-actions" status="APPROVED">GitHub Actions</Tool>
      <Repository>GitHub (github.com/vonomarap/kanokna)</Repository>
      <Workflows>
        <Workflow name="ci.yml" trigger="push, pull_request">
          <Stage order="1">Checkout and cache dependencies</Stage>
          <Stage order="2">Build with Maven (mvn verify -DskipTests)</Stage>
          <Stage order="3">Unit tests (mvn test)</Stage>
          <Stage order="4">Integration tests with Testcontainers</Stage>
          <Stage order="5">ArchUnit architecture tests</Stage>
          <Stage order="6">Contract tests (OpenAPI, Protobuf validation)</Stage>
          <Stage order="7">Security scan (SAST via CodeQL, dependency check via Dependabot)</Stage>
          <Stage order="8">Code coverage report (JaCoCo)</Stage>
        </Workflow>
        <Workflow name="build-and-push.yml" trigger="push to main">
          <Stage order="1">Build container images (Jib)</Stage>
          <Stage order="2">Push to GitHub Container Registry (ghcr.io)</Stage>
          <Stage order="3">Update image tags in Helm values</Stage>
        </Workflow>
        <Workflow name="deploy-stage.yml" trigger="workflow_dispatch, push to main">
          <Stage order="1">Deploy to stage environment (Kubernetes)</Stage>
          <Stage order="2">Run smoke tests</Stage>
          <Stage order="3">Run E2E tests (optional)</Stage>
        </Workflow>
        <Workflow name="deploy-prod.yml" trigger="workflow_dispatch (manual)">
          <Stage order="1">Require approval from CODEOWNERS</Stage>
          <Stage order="2">Deploy to production (Kubernetes)</Stage>
          <Stage order="3">Run smoke tests</Stage>
          <Stage order="4">Notify Slack/Teams on success/failure</Stage>
        </Workflow>
      </Workflows>
      <Configuration>
        <Item>Reusable workflows for common steps</Item>
        <Item>Matrix builds for multiple Java versions (if needed)</Item>
        <Item>Caching for Maven dependencies (.m2/repository)</Item>
        <Item>Secrets stored in GitHub Secrets</Item>
        <Item>Environment protection rules for prod</Item>
      </Configuration>
      <Links>
        <Link ref="Technology.xml#TECH-jib" />
        <Link ref="Technology.xml#TECH-kubernetes" />
      </Links>
    </CI>
  </BuildAndDeployment>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       TESTING
       ═══════════════════════════════════════════════════════════════════════════ -->
  <Testing>
    <!-- ─────────────────────────────────────────────────────────────────────────
         UNIT TESTING
         ───────────────────────────────────────────────────────────────────────── -->
    <Framework id="TECH-junit5">
      <Name>JUnit 5 (Jupiter)</Name>
      <Version>5.11.x (via Spring Boot BOM)</Version>
      <Usage>Unit and integration test framework for all services</Usage>
      <Configuration>
        <Item>@Nested for test organization by scenario</Item>
        <Item>@ParameterizedTest for data-driven tests</Item>
        <Item>@DisplayName for human-readable test names</Item>
      </Configuration>
      <Links>
        <Link ref="DEC-TEST-UNIT" />
      </Links>
    </Framework>

    <Framework id="TECH-mockito">
      <Name>Mockito</Name>
      <Version>5.x (via Spring Boot BOM)</Version>
      <Usage>Mocking for unit tests - ports, repositories, external services</Usage>
      <Configuration>
        <Item>@Mock for driven port interfaces</Item>
        <Item>@InjectMocks for application services under test</Item>
        <Item>Avoid mocking in domain layer - domain logic should be tested as pure functions</Item>
      </Configuration>
      <Links>
        <Link ref="DEC-TEST-UNIT" />
      </Links>
    </Framework>

    <Framework id="TECH-assertj">
      <Name>AssertJ</Name>
      <Version>3.x (via Spring Boot BOM)</Version>
      <Usage>Fluent assertions for readable test assertions</Usage>
      <Configuration>
        <Item>Prefer assertThat() over JUnit assertions</Item>
        <Item>Use extracting() for collection assertions</Item>
        <Item>Use satisfies() for complex object assertions</Item>
      </Configuration>
    </Framework>

    <!-- ─────────────────────────────────────────────────────────────────────────
         INTEGRATION TESTING
         ───────────────────────────────────────────────────────────────────────── -->
    <Framework id="TECH-testcontainers">
      <Name>Testcontainers</Name>
      <Version>1.20.x</Version>
      <Usage>Integration tests with real dependencies (PostgreSQL, Kafka, Redis, Elasticsearch)</Usage>
      <Configuration>
        <Item>Shared containers via test-support module to reduce startup time</Item>
        <Item>@Container annotation for declarative container lifecycle</Item>
        <Item>Reusable containers enabled for local dev (testcontainers.reuse.enable=true)</Item>
      </Configuration>
      <Containers>
        <Container id="TC-POSTGRES">PostgreSQL 16 for persistence tests</Container>
        <Container id="TC-KAFKA">Kafka (Redpanda) for event publishing tests</Container>
        <Container id="TC-REDIS">Redis 7 for cache integration tests</Container>
        <Container id="TC-ELASTICSEARCH">Elasticsearch 8.17.1 for search-service tests</Container>
      </Containers>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-MAINT-TESTABILITY" />
        <Link ref="DEC-TEST-GRPC-INTEGRATION" />
        <Link ref="DEC-TEST-E2E" />
      </Links>
    </Framework>

    <Framework id="TECH-spring-grpc-test">
      <Name>Spring gRPC Test</Name>
      <Version>1.0.x (via spring-grpc-spring-boot-starter)</Version>
      <Usage>gRPC integration testing for inter-service communication</Usage>
      <Configuration>
        <Item>@GrpcClientTest for client-side integration tests</Item>
        <Item>@SpringBootTest with grpc-inprocess for full server tests</Item>
        <Item>GrpcMock for mocking external gRPC services</Item>
      </Configuration>
      <Links>
        <Link ref="DEC-TEST-GRPC-INTEGRATION" />
      </Links>
    </Framework>

    <Framework id="TECH-spring-web-test">
      <Name>Spring Web Test (MockMvc / WebTestClient)</Name>
      <Version>via Spring Boot BOM</Version>
      <Usage>Gateway and REST endpoint testing</Usage>
      <Configuration>
        <Item>MockMvc for @WebMvcTest sliced tests (synchronous)</Item>
        <Item>WebTestClient for reactive/gateway tests</Item>
        <Item>@AutoConfigureMockMvc with @SpringBootTest for full context</Item>
      </Configuration>
      <Links>
        <Link ref="DEC-TEST-GATEWAY" />
      </Links>
    </Framework>

    <!-- ─────────────────────────────────────────────────────────────────────────
         ARCHITECTURE TESTING
         ───────────────────────────────────────────────────────────────────────── -->
    <Framework id="TECH-archunit">
      <Name>ArchUnit</Name>
      <Version>1.2.x</Version>
      <Usage>Enforce architectural rules (hexagonal layers, dependency direction)</Usage>
      <Rules>
        <Rule id="ARCH-001">Domain layer must not depend on adapters or application layer</Rule>
        <Rule id="ARCH-002">Application layer must not depend on adapters</Rule>
        <Rule id="ARCH-003">No Spring annotations in domain layer</Rule>
        <Rule id="ARCH-004">No JPA annotations in domain layer</Rule>
        <Rule id="ARCH-005">gRPC generated stubs confined to adapters packages</Rule>
        <Rule id="ARCH-006">No cyclic dependencies between packages</Rule>
      </Rules>
      <Configuration>
        <Item>ArchitectureTest.java in each service (run by Surefire)</Item>
        <Item>Shared rule library in test-support module</Item>
      </Configuration>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-MAINT-MODULARITY" />
      </Links>
    </Framework>

    <!-- ─────────────────────────────────────────────────────────────────────────
         CONTRACT TESTING
         ───────────────────────────────────────────────────────────────────────── -->
    <Framework id="TECH-spring-cloud-contract">
      <Name>Spring Cloud Contract</Name>
      <Version>4.2.x (via Spring Cloud BOM 2025.1.x)</Version>
      <Usage>Producer/consumer contract testing for gRPC and REST APIs</Usage>
      <Configuration>
        <Item>Groovy DSL contracts in api-contracts/src/test/resources/contracts/</Item>
        <Item>Producer verifier generates tests from contracts</Item>
        <Item>Consumer stubs auto-generated and published to stub repository</Item>
        <Item>@AutoConfigureStubRunner for consumer-side testing</Item>
      </Configuration>
      <Workflow>
        <Step order="1">Define contracts in api-contracts module (Groovy DSL)</Step>
        <Step order="2">Producer service verifies contracts via generated tests</Step>
        <Step order="3">Stubs published to local Maven or Artifactory</Step>
        <Step order="4">Consumer services use @AutoConfigureStubRunner in tests</Step>
      </Workflow>
      <Links>
        <Link ref="DEC-TEST-CONTRACTS" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-api-contracts" />
      </Links>
    </Framework>

    <Framework id="TECH-openapi-validation">
      <Name>OpenAPI Contract Validation</Name>
      <Tools>
        <Tool id="TOOL-spectral">Spectral - OpenAPI linting and validation</Tool>
        <Tool id="TOOL-openapi-diff">OpenAPI-diff - breaking change detection</Tool>
      </Tools>
      <Usage>Validate OpenAPI specs and detect breaking changes in CI</Usage>
      <Links>
        <Link ref="DevelopmentPlan.xml#ContractEvolutionPolicy" />
      </Links>
    </Framework>

    <!-- ─────────────────────────────────────────────────────────────────────────
         COVERAGE AND QUALITY
         ───────────────────────────────────────────────────────────────────────── -->
    <Framework id="TECH-jacoco">
      <Name>JaCoCo</Name>
      <Version>0.8.x (via Maven plugin)</Version>
      <Usage>Code coverage measurement and enforcement</Usage>
      <Configuration>
        <Item>Aggregate report across all modules</Item>
        <Item>Exclude generated code (Protobuf, MapStruct)</Item>
        <Item>Exclude adapters.*.mapper packages from branch coverage</Item>
        <Item>CI fails if coverage below thresholds</Item>
      </Configuration>
      <Thresholds>
        <Threshold metric="LINE" minimum="0.80">80% line coverage</Threshold>
        <Threshold metric="BRANCH" minimum="0.70">70% branch coverage</Threshold>
      </Thresholds>
      <Links>
        <Link ref="DEC-TEST-COVERAGE" />
      </Links>
    </Framework>

    <!-- ─────────────────────────────────────────────────────────────────────────
         NAMING CONVENTIONS
         ───────────────────────────────────────────────────────────────────────── -->
    <NamingConventions>
      <Convention pattern="*Test.java" runner="surefire">
        Unit tests - domain and application layer isolation tests
      </Convention>
      <Convention pattern="*IT.java" runner="failsafe">
        Integration tests - persistence, Kafka, external services with Testcontainers
      </Convention>
      <Convention pattern="*GrpcIntegrationTest.java" runner="failsafe">
        gRPC integration tests - client/server communication tests
      </Convention>
      <Convention pattern="*ContractTest.java" runner="failsafe">
        Contract tests - Spring Cloud Contract verifier tests
      </Convention>
      <Convention pattern="*E2ETest.java" runner="failsafe" profile="e2e">
        End-to-end tests - full stack with all infrastructure
      </Convention>
      <Convention pattern="ArchitectureTest.java" runner="surefire">
        Architecture tests - ArchUnit hexagonal layer enforcement
      </Convention>
    </NamingConventions>

    <!-- ─────────────────────────────────────────────────────────────────────────
         MAVEN PLUGIN CONFIGURATION
         ───────────────────────────────────────────────────────────────────────── -->
    <MavenPlugins>
      <Plugin id="PLUGIN-surefire">
        <ArtifactId>maven-surefire-plugin</ArtifactId>
        <Version>3.2.5</Version>
        <Configuration>
          <Item>Runs *Test.java and ArchitectureTest.java</Item>
          <Item>Excludes *IT.java, *E2ETest.java, *ContractTest.java</Item>
          <Item>Phase: test</Item>
        </Configuration>
      </Plugin>
      <Plugin id="PLUGIN-failsafe">
        <ArtifactId>maven-failsafe-plugin</ArtifactId>
        <Version>3.2.5</Version>
        <Configuration>
          <Item>Runs *IT.java, *ContractTest.java, *GrpcIntegrationTest.java</Item>
          <Item>Phase: integration-test / verify</Item>
          <Item>E2E tests via profile: -Pe2e</Item>
        </Configuration>
      </Plugin>
    </MavenPlugins>
  </Testing>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       DECISIONS
       ═══════════════════════════════════════════════════════════════════════════ -->
  <Decisions>
    <Decision id="DEC-DB-ENGINE" status="APPROVED">
      <Title>Primary OLTP Database</Title>
      <Selected>PostgreSQL</Selected>
      <Alternatives>
        <Alternative>MySQL</Alternative>
        <Alternative>MariaDB</Alternative>
      </Alternatives>
      <Rationale>
        PostgreSQL offers superior support for JSON columns, full-text search fallback,
        and advanced data types. Strong community and cloud provider support.
      </Rationale>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-SCALE-DB-PER-SERVICE" />
      </Links>
    </Decision>

    <Decision id="DEC-SEARCH-ENGINE" status="APPROVED">
      <Title>Search Engine</Title>
      <Selected>Elasticsearch</Selected>
      <Alternatives>
        <Alternative>OpenSearch</Alternative>
        <Alternative>Typesense</Alternative>
        <Alternative>Meilisearch</Alternative>
      </Alternatives>
      <Rationale>
        Elasticsearch is industry standard for faceted search and autocomplete.
        Mature ecosystem, excellent Spring Data integration.
      </Rationale>
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-SEARCH-PRODUCTS" />
      </Links>
    </Decision>

    <Decision id="DEC-ES-VERSION-UPGRADE" status="APPROVED">
      <Title>Elasticsearch Version 8.17.1</Title>
      <Selected>Elasticsearch 8.17.1</Selected>
      <Alternatives>
        <Alternative>Elasticsearch 9.x (latest release)</Alternative>
      </Alternatives>
      <Rationale>
        Updated to Elasticsearch 8.17.1 per user request. ES 8.17.1 is a stable LTS release
        with broad ecosystem compatibility. Testcontainers remain at 1.20.x for StringUtils fix.
      </Rationale>
      <ApprovedBy>User (2026-01-27)</ApprovedBy>
      <Links>
        <Link ref="Technology.xml#TECH-elasticsearch" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-search-service" />
      </Links>
    </Decision>

    <Decision id="DEC-TESTCONTAINERS-UPGRADE" status="APPROVED">
      <Title>Testcontainers Version Upgrade to 1.20.x</Title>
      <Selected>Testcontainers 1.20.x</Selected>
      <Alternatives>
        <Alternative>Patch 1.19.x with workaround for StringUtils bug</Alternative>
      </Alternatives>
      <Rationale>
        Testcontainers 1.19.3 has shaded commons-lang3 bug causing NoClassDefFoundError: StringUtils
        in integration tests. Upgrading to 1.20.x resolves this issue without workarounds.
        Required for search-service integration tests to pass.
      </Rationale>
      <ApprovedBy>AWO-20260126-01</ApprovedBy>
      <Links>
        <Link ref="Technology.xml#TECH-testcontainers" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-test-support" />
      </Links>
    </Decision>

    <Decision id="DEC-EVENT-SERIALIZATION" status="APPROVED">
      <Title>Event Serialization Format</Title>
      <Selected>Protobuf</Selected>
      <Alternatives>
        <Alternative>Avro</Alternative>
        <Alternative>JSON</Alternative>
      </Alternatives>
      <Rationale>
        Protobuf provides compact binary format, strong typing, and schema evolution.
        Schema Registry integration ensures compatibility.
      </Rationale>
      <Links>
        <Link ref="DevelopmentPlan.xml#ContractEvolutionPolicy" />
      </Links>
    </Decision>

    <Decision id="DEC-IDENTITY-PROVIDER" status="APPROVED">
      <Title>Identity Provider (Environment-Specific)</Title>
      <Selected>Keycloak (dev/stage), Auth0 (prod)</Selected>
      <Alternatives>
        <Alternative>Okta</Alternative>
        <Alternative>AWS Cognito</Alternative>
        <Alternative>Keycloak for all environments</Alternative>
      </Alternatives>
      <Rationale>
        Keycloak provides full OAuth2/OIDC support for dev/stage with easy Docker deployment.
        Auth0 for production reduces operational and security burden with managed infrastructure,
        automatic security updates, and enterprise-grade SLAs.
      </Rationale>
      <Links>
        <Link ref="RequirementsAnalysis.xml#ACT-IDENTITY-PROVIDER" />
        <Link ref="Technology.xml#TECH-keycloak" />
        <Link ref="Technology.xml#TECH-auth0" />
      </Links>
    </Decision>

    <Decision id="DEC-PAYMENT-GATEWAY" status="APPROVED">
      <Title>Payment Gateway Provider</Title>
      <Selected>YooKassa (YooMoney)</Selected>
      <Alternatives>
        <Alternative>Stripe</Alternative>
        <Alternative>Tinkoff Acquiring</Alternative>
        <Alternative>Sberbank Acquiring</Alternative>
      </Alternatives>
      <Rationale>
        YooKassa is the primary payment gateway for the Russian market.
        Supports all major Russian payment methods (Mir, SberPay, YooMoney wallet),
        provides 54-FZ compliant receipts, and has robust API and webhook infrastructure.
        Stripe is not optimal for Russia-focused MVP.
      </Rationale>
      <Links>
        <Link ref="RequirementsAnalysis.xml#ACT-PAYMENT-GATEWAY" />
        <Link ref="Technology.xml#TECH-yookassa" />
      </Links>
    </Decision>

    <Decision id="DEC-INTER-SERVICE-COMM" status="APPROVED">
      <Title>Inter-Service Communication Protocol</Title>
      <Selected>gRPC</Selected>
      <Alternatives>
        <Alternative>REST (HTTP/JSON)</Alternative>
        <Alternative>GraphQL Federation</Alternative>
      </Alternatives>
      <Rationale>
        gRPC provides efficient binary serialization (Protobuf), strong typing via
        service definitions, streaming support, and excellent performance for
        synchronous inter-service calls. Contract-first approach aligns with
        GRACE methodology. REST retained for external/public APIs.
      </Rationale>
      <Links>
        <Link ref="Technology.xml#TECH-grpc" />
        <Link ref="Technology.xml#TECH-protobuf" />
      </Links>
    </Decision>

    <Decision id="DEC-CI-CD-PLATFORM" status="APPROVED">
      <Title>CI/CD Platform</Title>
      <Selected>GitHub Actions</Selected>
      <Alternatives>
        <Alternative>GitLab CI</Alternative>
        <Alternative>Jenkins</Alternative>
        <Alternative>CircleCI</Alternative>
      </Alternatives>
      <Rationale>
        GitHub Actions integrates natively with GitHub repository. Provides
        reusable workflows, matrix builds, and easy secrets management.
        Large marketplace of actions for common tasks.
      </Rationale>
      <Links>
        <Link ref="Technology.xml#TECH-github-actions" />
      </Links>
    </Decision>

    <Decision id="DEC-FEATURE-FLAGS" status="ASSUMED">
      <Title>Feature Flag System</Title>
      <Selected>Unleash</Selected>
      <Alternatives>
        <Alternative>LaunchDarkly</Alternative>
        <Alternative>Flagsmith</Alternative>
      </Alternatives>
      <Rationale>
        Unleash is open-source and self-hostable. Sufficient for initial needs;
        may migrate to managed service if scale demands.
      </Rationale>
    </Decision>

    <!-- ═══════════════════════════════════════════════════════════════════════════
         ARCHITECTURAL PATTERN DECISIONS (Promoted from Service Handoffs)
         ═══════════════════════════════════════════════════════════════════════════ -->
    <Decision id="DEC-ARCH-RULE-ENGINE-STRATEGY" status="APPROVED">
      <Title>Domain Rule Engine Strategy</Title>
      <Selected>Domain-native rule evaluation with aggregate-owned RuleSet</Selected>
      <Alternatives>
        <Alternative>External rule engine (Drools, Easy Rules)</Alternative>
        <Alternative>Configuration-driven rules in database with generic evaluator</Alternative>
      </Alternatives>
      <Rationale>
        Rules are core domain logic and should be explicit, testable, and version-controlled
        with the domain model. External engines add complexity and make rules opaque to
        domain experts. A domain-native approach keeps business rules in domain services
        without external dependencies. Complex engines (Drools) can be introduced later
        for specific high-volume rule scenarios if needed.
      </Rationale>
      <ApplicableServices>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-catalog-configuration-service">Configuration
          validation rules</ServiceRef>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-pricing-service">Campaign and discount rules</ServiceRef>
      </ApplicableServices>
      <PromotedFrom handoff="Handoff-20251230-07" originalId="DEC-CATALOG-RULE-ENGINE" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-CATALOG-CONFIGURE-ITEM" />
        <Link ref="RequirementsAnalysis.xml#UC-PRICING-QUOTE" />
      </Links>
    </Decision>

    <Decision id="DEC-ARCH-ENTITY-VERSIONING" status="APPROVED">
      <Title>Domain Entity Versioning Strategy</Title>
      <Selected>Soft-delete with versioned snapshots (Version aggregate pattern)</Selected>
      <Alternatives>
        <Alternative>Event sourcing for full history</Alternative>
        <Alternative>Temporal tables (database-level)</Alternative>
        <Alternative>No versioning (overwrite in place)</Alternative>
      </Alternatives>
      <Rationale>
        Versioned snapshots support audit trail, rollback capability, and time-travel queries
        for historical data (e.g., orders referencing catalog state at order time, pricing
        at quote time). Simpler than full event sourcing while providing sufficient history.
        Implemented via Version aggregate (CatalogVersion, PriceBookVersion) that captures
        snapshots on publish. Soft-delete prevents accidental data loss while keeping
        referential integrity for historical records.
      </Rationale>
      <ApplicableServices>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-catalog-configuration-service">CatalogVersion
          for product templates</ServiceRef>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-pricing-service">PriceBookVersion for pricing
          history</ServiceRef>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-order-service">Order snapshots (implicit, stored
          per order)</ServiceRef>
      </ApplicableServices>
      <Implementation>
        <Pattern>Version aggregate with JSONB snapshot column</Pattern>
        <SoftDelete>status column with DRAFT/ACTIVE/ARCHIVED states</SoftDelete>
        <Audit>version_number, published_at, published_by columns</Audit>
      </Implementation>
      <PromotedFrom handoff="Handoff-20251230-07" originalId="DEC-CATALOG-VERSIONING" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-CATALOG-ADMIN-MANAGE" />
        <Link ref="RequirementsAnalysis.xml#UC-PRICING-ADMIN-MANAGE" />
      </Links>
    </Decision>

    <!-- ═══════════════════════════════════════════════════════════════════════════
         PRICING SERVICE DECISIONS (Promoted from Handoff-20251231-02)
         ═══════════════════════════════════════════════════════════════════════════ -->
    <Decision id="DEC-PRICING-BASE-PRICE-FORMULA" status="APPROVED">
      <Title>Base Price Calculation Formula</Title>
      <Selected>Area-based pricing: base_price = area_m2 * price_per_m2</Selected>
      <Alternatives>
        <Alternative>Per-unit fixed pricing</Alternative>
        <Alternative>Linear dimension pricing (perimeter-based)</Alternative>
        <Alternative>Component-based pricing</Alternative>
      </Alternatives>
      <Rationale>
        Windows and doors are priced by area (m²). Price books define price_per_m2
        for each product family. This approach reflects manufacturing cost proportional
        to material usage. Minimum area thresholds ensure profitability on small items.
      </Rationale>
      <PromotedFrom handoff="Handoff-20251231-02" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-PRICING-QUOTE" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-pricing-service" />
      </Links>
    </Decision>

    <Decision id="DEC-PRICING-PREMIUM-TYPES" status="APPROVED">
      <Title>Option Premium Types</Title>
      <Selected>Two premium types: ABSOLUTE (fixed amount) and PERCENTAGE (of base price)</Selected>
      <Alternatives>
        <Alternative>Single premium type (absolute only)</Alternative>
        <Alternative>Tiered pricing by quantity</Alternative>
        <Alternative>Complex formula-based premiums</Alternative>
      </Alternatives>
      <Rationale>
        Some options (handles, locks) have fixed costs regardless of product size.
        Others (premium glazing, special lamination) scale with product area.
        Percentage premiums are calculated on base price, not running total,
        ensuring predictable pricing and avoiding compound effects.
      </Rationale>
      <PromotedFrom handoff="Handoff-20251231-02" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-PRICING-QUOTE" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-pricing-service" />
      </Links>
    </Decision>

    <Decision id="DEC-PRICING-DISCOUNT-PRECEDENCE" status="APPROVED">
      <Title>Discount Precedence and Stacking</Title>
      <Selected>Campaign discounts apply first, then promo codes. Max combined discount: 30%</Selected>
      <Alternatives>
        <Alternative>No stacking (best single discount wins)</Alternative>
        <Alternative>Unlimited stacking</Alternative>
        <Alternative>Customer-type based discount priority</Alternative>
      </Alternatives>
      <Rationale>
        Campaign discounts are business-driven (seasonal sales, clearance).
        Promo codes are customer-acquired (marketing, loyalty). Stacking allowed
        but capped at 30% to protect margins. Best discount wins within each category.
        Order of application (campaign first) ensures consistent behavior.
      </Rationale>
      <PromotedFrom handoff="Handoff-20251231-02" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-PRICING-QUOTE" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-pricing-service" />
      </Links>
    </Decision>

    <Decision id="DEC-PRICING-CURRENCY" status="APPROVED">
      <Title>Currency Support Strategy</Title>
      <Selected>Single currency (RUB) initially; multi-currency deferred to Wave 5</Selected>
      <Alternatives>
        <Alternative>Multi-currency from day one</Alternative>
        <Alternative>USD as base with conversion</Alternative>
        <Alternative>Dual currency (RUB + USD)</Alternative>
      </Alternatives>
      <Rationale>
        Per RequirementsAnalysis.xml#ASSUM-003, initial launch targets single market (Russia).
        Price books are currency-specific. Multi-currency adds exchange rate management
        complexity that can be deferred. Money value object supports currency for
        future expansion without schema changes.
      </Rationale>
      <PromotedFrom handoff="Handoff-20251231-02" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#ASSUM-003" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-pricing-service" />
      </Links>
    </Decision>

    <Decision id="DEC-PRICING-TAX-STRATEGY" status="APPROVED">
      <Title>Tax Calculation Strategy</Title>
      <Selected>Region-based VAT with Russia (20%) as default</Selected>
      <Alternatives>
        <Alternative>Flat tax rate for all regions</Alternative>
        <Alternative>External tax service integration</Alternative>
        <Alternative>No tax calculation (defer to invoicing)</Alternative>
      </Alternatives>
      <Rationale>
        Russian VAT is 20% on most goods and must be shown in quotes for transparency
        and 54-FZ compliance. Tax rules stored per region allow future expansion to
        other markets. Tax is calculated on subtotal (after discounts, before rounding).
      </Rationale>
      <PromotedFrom handoff="Handoff-20251231-02" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-PRICING-QUOTE" />
        <Link ref="Technology.xml#TECH-yookassa" />
      </Links>
    </Decision>

    <Decision id="DEC-PRICING-ROUNDING" status="APPROVED">
      <Title>Price Rounding Policy</Title>
      <Selected>HALF_UP rounding to 2 decimal places for RUB</Selected>
      <Alternatives>
        <Alternative>Truncation (floor)</Alternative>
        <Alternative>HALF_EVEN (banker's rounding)</Alternative>
        <Alternative>Ceiling (always round up)</Alternative>
      </Alternatives>
      <Rationale>
        Standard commercial rounding (HALF_UP) is customer-expected behavior.
        Applied as final step after all calculations to avoid cumulative errors.
        Different currencies may have different precision (e.g., JPY has 0 decimals)
        and the rounding service supports currency-specific configuration.
      </Rationale>
      <PromotedFrom handoff="Handoff-20251231-02" />
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-pricing-service" />
      </Links>
    </Decision>

    <Decision id="DEC-PRICING-QUOTE-TTL" status="APPROVED">
      <Title>Quote Cache TTL</Title>
      <Selected>5 minutes TTL in Redis</Selected>
      <Alternatives>
        <Alternative>No caching (recalculate every time)</Alternative>
        <Alternative>Longer TTL (15-30 minutes)</Alternative>
        <Alternative>Session-based caching only</Alternative>
      </Alternatives>
      <Rationale>
        Quotes are expensive to calculate (DB lookups, rule evaluation). 5-minute TTL
        balances freshness with performance. Quote ID + hash of inputs used as cache
        key for idempotency. Cache is invalidated on price book updates to ensure
        customers see current prices.
      </Rationale>
      <PromotedFrom handoff="Handoff-20251231-02" />
      <Links>
        <Link ref="Technology.xml#TECH-redis" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-pricing-service" />
      </Links>
    </Decision>

    <Decision id="DEC-DISTRIBUTED-LOCK" status="APPROVED">
      <Title>Distributed Lock Mechanism for Cross-Instance Coordination</Title>
      <Selected>Redis-based distributed locks with Redisson</Selected>
      <Alternatives>
        <Alternative>Database advisory locks (requires service-specific DB)</Alternative>
        <Alternative>Elasticsearch document-based locks (non-standard)</Alternative>
        <Alternative>ZooKeeper/etcd (additional infrastructure)</Alternative>
      </Alternatives>
      <Rationale>
        Redis is already in the stack (TECH-redis) for caching and rate limiting.
        Redisson provides reliable distributed locks with TTL, auto-renewal, and
        fairness options. Used by search-service for reindex coordination to prevent
        concurrent full reindex operations. Lock TTL set to 30 minutes with renewal
        to handle long-running reindex jobs safely.
      </Rationale>
      <Configuration>
        <Item>Lock provider: Redisson (RedissonClient)</Item>
        <Item>Spring Integration: spring-integration-redis DistributedLock abstraction</Item>
        <Item>Default lock TTL: 30 seconds (auto-renewed for long operations)</Item>
        <Item>Wait timeout: Configurable per use case (0 for reindex = fail-fast)</Item>
      </Configuration>
      <UseCases>
        <UseCase>FC-search-reindexCatalog: Exclusive lock for catalog reindex</UseCase>
        <UseCase>Future: Other singleton operations requiring coordination</UseCase>
      </UseCases>
      <AddedFor>ISS-SEARCH-BLUEPRINT-002</AddedFor>
      <Links>
        <Link ref="Technology.xml#TECH-redis" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-search-service" />
      </Links>
    </Decision>

    <!-- ═══════════════════════════════════════════════════════════════════════════
         CART SERVICE DECISIONS (Promoted from Handoff-20260109-01-W1-T6-CartService)
         ═══════════════════════════════════════════════════════════════════════════ -->
    <Decision id="DEC-CART-ANONYMOUS" status="APPROVED">
      <Title>Anonymous Cart Identification Strategy</Title>
      <Selected>Session-based cart ID stored in HTTP-only cookie with Redis session storage</Selected>
      <Alternatives>
        <Alternative>Redis key only (no cookie, stateless lookup by client ID)</Alternative>
        <Alternative>Database-only anonymous carts (no Redis)</Alternative>
        <Alternative>Local storage cart ID (client-generated)</Alternative>
      </Alternatives>
      <Rationale>
        HTTP-only cookie provides secure session binding. Redis session storage enables
        fast cart retrieval and automatic TTL management. Cookie name: KANOKNA_CART_SESSION.
        Server generates cart_id on first add-to-cart for anonymous users.
        Authenticated users have cart_id derived from customer_id (deterministic).
      </Rationale>
      <Configuration>
        <Item>Cookie name: KANOKNA_CART_SESSION</Item>
        <Item>Cookie attributes: HttpOnly, Secure (prod), SameSite=Lax</Item>
        <Item>Cookie max-age: 7 days (aligned with anonymous cart TTL)</Item>
        <Item>Redis key pattern: cart:session:{session_id}</Item>
        <Item>Redis key pattern (auth): cart:customer:{customer_id}</Item>
      </Configuration>
      <PromotedFrom handoff="Handoff-20260109-01-W1-T6-CartService" />
      <Links>
        <Link ref="Technology.xml#TECH-redis" />
        <Link ref="RequirementsAnalysis.xml#UC-CART-MANAGE" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-cart-service" />
      </Links>
    </Decision>

    <Decision id="DEC-CART-TTL" status="APPROVED">
      <Title>Cart Expiration Policy</Title>
      <Selected>7 days for anonymous carts; indefinite for authenticated carts</Selected>
      <Alternatives>
        <Alternative>30 days for all carts</Alternative>
        <Alternative>24 hours for anonymous, 30 days for authenticated</Alternative>
        <Alternative>No expiration (manual cleanup only)</Alternative>
      </Alternatives>
      <Rationale>
        7-day TTL for anonymous carts balances user convenience with storage efficiency.
        Authenticated carts persist indefinitely to support long sales cycles common in
        windows/doors purchases. Carts transition to ABANDONED status after inactivity
        threshold for notification-service abandoned cart reminders (separate from TTL).
      </Rationale>
      <Configuration>
        <Item>Anonymous cart TTL: 7 days (168 hours)</Item>
        <Item>Authenticated cart TTL: Indefinite (no automatic expiration)</Item>
        <Item>Abandoned cart threshold: 72 hours inactivity (for notification triggers)</Item>
        <Item>Redis TTL applied to session key for anonymous carts</Item>
        <Item>Database soft-delete for authenticated carts after 365 days inactivity</Item>
      </Configuration>
      <PromotedFrom handoff="Handoff-20260109-01-W1-T6-CartService" />
      <Links>
        <Link ref="Technology.xml#TECH-redis" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-cart-service" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-notification-service" />
      </Links>
    </Decision>

    <Decision id="DEC-CART-MERGE" status="APPROVED">
      <Title>Anonymous to Authenticated Cart Merge Strategy</Title>
      <Selected>Merge items into authenticated cart with conflict resolution (keep both, sum
        quantities)</Selected>
      <Alternatives>
        <Alternative>Replace authenticated cart with anonymous cart</Alternative>
        <Alternative>Discard anonymous cart on login</Alternative>
        <Alternative>Prompt user to choose which cart to keep</Alternative>
      </Alternatives>
      <Rationale>
        Merge strategy preserves user work from both sessions. When same product+configuration
        exists in both carts, quantities are summed. After merge, anonymous cart is deleted.
        Price quotes are refreshed during merge to ensure current pricing. Merge is triggered
        automatically on successful authentication (login/signup) when anonymous cart exists.
      </Rationale>
      <MergeRules>
        <Rule id="MERGE-001">Items with identical configuration hash are merged (quantities summed)</Rule>
        <Rule id="MERGE-002">Items with different configurations are both kept</Rule>
        <Rule id="MERGE-003">Applied promo code from authenticated cart takes precedence</Rule>
        <Rule id="MERGE-004">If no promo code on auth cart, anonymous cart promo is preserved</Rule>
        <Rule id="MERGE-005">All prices are refreshed after merge</Rule>
        <Rule id="MERGE-006">Anonymous cart is deleted after successful merge</Rule>
      </MergeRules>
      <PromotedFrom handoff="Handoff-20260109-01-W1-T6-CartService" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-CART-MANAGE" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-cart-service" />
      </Links>
    </Decision>

    <Decision id="DEC-CART-PRICE-LOCK" status="APPROVED">
      <Title>Quote Validity and Price Lock Strategy</Title>
      <Selected>Prices cached per item with 5-minute quote TTL; warn on stale, auto-refresh on
        checkout</Selected>
      <Alternatives>
        <Alternative>Always fetch fresh prices (no caching)</Alternative>
        <Alternative>Lock prices at add-to-cart time until checkout</Alternative>
        <Alternative>Lock prices for 24 hours</Alternative>
      </Alternatives>
      <Rationale>
        Cart items store quote_id from pricing-service with 5-minute TTL (per
        DEC-PRICING-QUOTE-TTL).
        On GetCart, system checks quote validity. If stale, items marked as price_stale=true.
        Frontend displays staleness warning. CreateSnapshot always refreshes all prices
        to ensure checkout uses current pricing. Customer must acknowledge price changes
        before checkout proceeds.
      </Rationale>
      <Configuration>
        <Item>Quote TTL: 5 minutes (from pricing-service cache)</Item>
        <Item>Staleness check: Compare quote valid_until with current time</Item>
        <Item>Auto-refresh: On CreateSnapshot (checkout)</Item>
        <Item>User notification: Frontend shows "Prices may have changed" badge</Item>
        <Item>Price change acknowledgement required if total differs > 1%</Item>
      </Configuration>
      <PromotedFrom handoff="Handoff-20260109-01-W1-T6-CartService" />
      <Links>
        <Link ref="Technology.xml#DEC-PRICING-QUOTE-TTL" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-pricing-service" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-cart-service" />
      </Links>
    </Decision>

    <Decision id="DEC-CART-STATE-MACHINE" status="APPROVED">
      <Title>Cart State Lifecycle</Title>
      <Selected>Four states: ACTIVE, CHECKED_OUT, ABANDONED, MERGED</Selected>
      <Alternatives>
        <Alternative>Only ACTIVE state (no state machine)</Alternative>
        <Alternative>ACTIVE, LOCKED, COMPLETED states</Alternative>
      </Alternatives>
      <Rationale>
        Cart state machine tracks lifecycle for analytics and operations:
        - ACTIVE: Default state, accepts modifications
        - CHECKED_OUT: Snapshot created, cart cleared, items moved to order
        - ABANDONED: Inactivity threshold exceeded (notification trigger)
        - MERGED: Anonymous cart merged into authenticated (terminal, soft-deleted)
        State changes are audited for analytics (abandoned cart rate, checkout conversion).
      </Rationale>
      <StateMachine>
        <State name="ACTIVE" initial="true">Cart accepts modifications</State>
        <State name="CHECKED_OUT" terminal="true">Snapshot created for order</State>
        <State name="ABANDONED">Inactive past threshold (notification trigger)</State>
        <State name="MERGED" terminal="true">Anonymous cart merged</State>
        <Transition from="ACTIVE" to="CHECKED_OUT" event="SNAPSHOT_CREATED" />
        <Transition from="ACTIVE" to="ABANDONED" event="INACTIVITY_THRESHOLD" />
        <Transition from="ABANDONED" to="ACTIVE" event="CART_MODIFIED" />
        <Transition from="ACTIVE" to="MERGED" event="CART_MERGED" />
        <Transition from="ABANDONED" to="MERGED" event="CART_MERGED" />
      </StateMachine>
      <PromotedFrom handoff="Handoff-20260109-01-W1-T6-CartService" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-CART-MANAGE" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-cart-service" />
      </Links>
    </Decision>

    <Decision id="DEC-CART-VALIDATION" status="APPROVED">
      <Title>Configuration Revalidation Strategy</Title>
      <Selected>Validate on add-to-cart and on GetCart (lazy revalidation)</Selected>
      <Alternatives>
        <Alternative>Validate only on add-to-cart</Alternative>
        <Alternative>Validate only on checkout</Alternative>
        <Alternative>No revalidation (trust stored configuration)</Alternative>
      </Alternatives>
      <Rationale>
        Product configurations may become invalid if catalog rules change after item was added.
        On GetCart, cart-service calls catalog-configuration-service.ValidateConfiguration for
        each item and marks items as validation_status=VALID|INVALID|UNKNOWN.
        Invalid items display warning; customer can reconfigure or remove.
        CreateSnapshot fails if any item is INVALID (customer must resolve first).
      </Rationale>
      <ValidationBehavior>
        <Item>Add-to-cart: Full validation required (reject invalid configurations)</Item>
        <Item>GetCart: Lazy revalidation with status flag (allow display of invalid items)</Item>
        <Item>CreateSnapshot: Full validation required (reject if any item invalid)</Item>
        <Item>Validation timeout: 2 seconds (use last known status on timeout)</Item>
      </ValidationBehavior>
      <PromotedFrom handoff="Handoff-20260109-01-W1-T6-CartService" />
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-catalog-configuration-service" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-cart-service" />
      </Links>
    </Decision>

    <!-- ═══════════════════════════════════════════════════════════════════════════
         DOMAIN ERROR HANDLING DECISIONS (From Handoff-20260117-01-W1-ERROR-HANDLING)
         ═══════════════════════════════════════════════════════════════════════════ -->
    <Decision id="DEC-DOMAIN-ERROR-PATTERN" status="APPROVED">
      <Title>Domain Error Handling Pattern</Title>
      <Selected>Static factory class with typed DomainException per service</Selected>
      <Alternatives>
        <Alternative>Throw IllegalArgumentException directly</Alternative>
        <Alternative>Domain-specific exception hierarchy per error type</Alternative>
        <Alternative>Result/Either type for all domain operations</Alternative>
      </Alternatives>
      <Rationale>
        Static factory pattern (AccountDomainErrors, CartDomainErrors) centralizes error creation,
        ensures consistent error codes, enables code completion, and keeps domain layer clean.
        DomainException from shared-kernel provides base class with code+message+optional cause.
        Typed subclasses (e.g., CartNotFoundException) used only when polymorphic handling needed.
      </Rationale>
      <Convention>
        <Item>Factory class: {BoundedContext}DomainErrors in com.kanokna.{service}.domain.exception</Item>
        <Item>Error code format: ERR-{PREFIX}-{ERROR-TYPE}</Item>
        <Item>Prefixes: ACCT (account), CART (cart), CAT (catalog), PRICE (pricing), SEARCH (search)</Item>
        <Item>Factory methods are static, return DomainException or typed subclass</Item>
        <Item>Factory class has private constructor, marked final</Item>
        <Item>Error messages include relevant context (IDs, values) for debugging</Item>
      </Convention>
      <ApplicableServices>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-account-service">AccountDomainErrors (implemented)</ServiceRef>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-cart-service">CartDomainErrors (implemented)</ServiceRef>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-catalog-configuration-service">CatalogDomainErrors</ServiceRef>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-pricing-service">PricingDomainErrors</ServiceRef>
        <ServiceRef ref="DevelopmentPlan.xml#DP-SVC-order-service">OrderDomainErrors (future)</ServiceRef>
      </ApplicableServices>
      <PromotedFrom handoff="Handoff-20260117-01-W1-ERROR-HANDLING" />
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-CODE-DOMAIN-ERROR-HANDLING" />
      </Links>
    </Decision>

    <Decision id="DEC-ERROR-CODE-REGISTRY" status="APPROVED">
      <Title>Service Error Code Prefix Registry</Title>
      <Selected>Centralized prefix registry to prevent collisions</Selected>
      <Registry>
        <Prefix code="ERR-ACCT" service="account-service">Account domain errors</Prefix>
        <Prefix code="ERR-CART" service="cart-service">Cart domain errors</Prefix>
        <Prefix code="ERR-CAT" service="catalog-configuration-service">Catalog domain errors</Prefix>
        <Prefix code="ERR-PRICE" service="pricing-service">Pricing domain errors</Prefix>
        <Prefix code="ERR-SEARCH" service="search-service" status="reserved">Search domain errors</Prefix>
        <Prefix code="ERR-ORDER" service="order-service" status="reserved">Order domain errors</Prefix>
        <Prefix code="ERR-MEDIA" service="media-service" status="reserved">Media domain errors</Prefix>
        <Prefix code="ERR-NOTIF" service="notification-service" status="reserved">Notification errors</Prefix>
      </Registry>
      <Rationale>
        Unique prefixes per service enable log aggregation, error categorization in monitoring,
        and clear ownership of error codes. Reserved prefixes prevent future conflicts.
      </Rationale>
      <PromotedFrom handoff="Handoff-20260117-01-W1-ERROR-HANDLING" />
      <Links>
        <Link ref="Technology.xml#DEC-DOMAIN-ERROR-PATTERN" />
      </Links>
    </Decision>

    <Decision id="DEC-PACKAGE-NAMING-CONVENTION" status="APPROVED">
      <Title>Java Package Naming Convention</Title>
      <Context>Need consistent package naming across all services for maintainability and IDE navigation</Context>
      <Selected>Package root follows bounded context name: com.kanokna.{bounded-context}.*</Selected>
      <Convention>
        <Item>Package root: com.kanokna.{bounded-context}.*</Item>
        <Item>Bounded context name uses lowercase, NO underscores</Item>
        <Item>Service name may differ from bounded context (e.g., catalog-configuration-service uses com.kanokna.catalog)</Item>
      </Convention>
      <Registry>
        <Service name="account-service" package="com.kanokna.account" />
        <Service name="cart-service" package="com.kanokna.cart" />
        <Service name="catalog-configuration-service" package="com.kanokna.catalog" />
        <Service name="pricing-service" package="com.kanokna.pricing" />
        <Service name="search-service" package="com.kanokna.search" />
        <Service name="order-service" package="com.kanokna.order" />
        <Service name="media-service" package="com.kanokna.media" />
        <Service name="notification-service" package="com.kanokna.notification" />
        <Service name="installation-service" package="com.kanokna.installation" />
        <Service name="reporting-service" package="com.kanokna.reporting" />
      </Registry>
      <Rationale>
        Bounded context names are stable domain concepts; service names may change.
        No underscores in package names follows Java conventions (JLS §6.1).
      </Rationale>
      <PromotedFrom handoff="Handoff-20260117-02-W1-PKG-RENAME" />
    </Decision>

    <Decision id="DEC-SRP-DECOMPOSITION-STRATEGY" status="APPROVED">
      <Title>Application Service Decomposition Strategy</Title>
      <Context>Large application service classes (>500 lines or >3 use case groups) should be decomposed for maintainability</Context>
      <Selected>Delegate Pattern - main service implements interfaces, delegates to specialized services</Selected>
      <Pattern>
        <Item>Main service (e.g., AccountApplicationService) remains as facade implementing use case interfaces</Item>
        <Item>Specialized services (e.g., ProfileService, AddressService) contain actual business logic</Item>
        <Item>Shared dependencies (repositories, validators) injected into both main and specialized services</Item>
        <Item>Transaction boundaries managed by main service @Transactional annotation</Item>
      </Pattern>
      <Benefits>
        <Item>Maintains API compatibility (existing interfaces unchanged)</Item>
        <Item>Each specialized service has single responsibility</Item>
        <Item>Easier unit testing of individual components</Item>
        <Item>Gradual migration possible</Item>
      </Benefits>
      <Threshold>
        <Item>Decompose when: >500 lines of actual code (excluding comments)</Item>
        <Item>Decompose when: >3 distinct use case groups with separate repositories</Item>
        <Item>Keep when: Operations are cohesive and share state</Item>
      </Threshold>
      <Links>
        <Link ref="DEC-ACCOUNT-DECOMPOSITION" />
        <Link ref="DEC-CART-DECOMPOSITION" />
        <Link ref="DEC-SEARCH-DECOMPOSITION" />
      </Links>
    </Decision>

    <Decision id="DEC-ACCOUNT-DECOMPOSITION" status="APPROVED">
      <Title>AccountApplicationService Decomposition</Title>
      <Context>AccountApplicationService (964 lines) has 4 use case groups with distinct repositories</Context>
      <Selected>DECOMPOSE into 3 specialized services + facade</Selected>
      <Decomposition>
        <FacadeService name="AccountApplicationService">
          <Role>Implements use case interfaces, delegates to specialized services</Role>
          <Interfaces>GetProfileUseCase, UpdateProfileUseCase, AddressManagementUseCase, ConfigurationManagementUseCase</Interfaces>
        </FacadeService>
        <SpecializedService name="ProfileService">
          <Package>com.kanokna.account.application.service</Package>
          <Responsibility>User profile CRUD operations</Responsibility>
          <Methods>getProfile, updateProfile, createProfileFromKeycloak</Methods>
          <Dependencies>UserProfileRepository, EventPublisher, CurrentUserProvider, AccountProperties</Dependencies>
        </SpecializedService>
        <SpecializedService name="AddressService">
          <Package>com.kanokna.account.application.service</Package>
          <Responsibility>Address management operations</Responsibility>
          <Methods>addAddress, updateAddress, deleteAddress, listAddresses</Methods>
          <Dependencies>SavedAddressRepository, UserProfileRepository, EventPublisher, CurrentUserProvider</Dependencies>
        </SpecializedService>
        <SpecializedService name="SavedConfigurationService">
          <Package>com.kanokna.account.application.service</Package>
          <Responsibility>Saved product configuration management</Responsibility>
          <Methods>saveConfiguration, listConfigurations, deleteConfiguration</Methods>
          <Dependencies>SavedConfigurationRepository, EventPublisher, CurrentUserProvider, ConfigurationSnapshotValidator</Dependencies>
        </SpecializedService>
      </Decomposition>
      <TransactionStrategy>
        <Item>Each specialized service method is transactional via @Transactional</Item>
        <Item>Facade delegates directly - no additional transaction wrapping needed</Item>
      </TransactionStrategy>
      <Rationale>
        Each group uses distinct repository (except Address needs UserProfile for loading).
        Clear separation of concerns improves testability and maintainability.
      </Rationale>
      <PromotedFrom handoff="Handoff-20260117-03-W1-SRP-DECOMPOSITION" />
    </Decision>

    <Decision id="DEC-CART-DECOMPOSITION" status="APPROVED">
      <Title>CartApplicationService Decomposition</Title>
      <Context>CartApplicationService (461 lines) reviewed for SRP compliance</Context>
      <Selected>KEEP - already well-structured with helper services</Selected>
      <ExistingStructure>
        <HelperService name="CartItemValidationService">Item validation logic</HelperService>
        <HelperService name="CartPricingService">Price calculation and refresh</HelperService>
        <HelperService name="CartMergingService">Anonymous to authenticated cart merge</HelperService>
        <HelperService name="CartCheckoutService">Checkout snapshot generation</HelperService>
        <HelperService name="CartPromoCodeService">Promo code application</HelperService>
        <HelperService name="CartDtoMapper">DTO mapping utilities</HelperService>
      </ExistingStructure>
      <Rationale>Cart-service already follows the decomposition pattern; no further action needed</Rationale>
    </Decision>

    <Decision id="DEC-SEARCH-DECOMPOSITION" status="APPROVED">
      <Title>SearchApplicationService Decomposition</Title>
      <Context>SearchApplicationService (1095 lines) reviewed for SRP compliance</Context>
      <Selected>KEEP - operations are cohesive around search domain</Selected>
      <Analysis>
        <UseCaseGroup name="Query" methods="searchProducts, autocomplete, getFacetValues, getProductById">Read-only operations</UseCaseGroup>
        <UseCaseGroup name="IndexManagement" methods="indexProduct, deleteProduct, reindexCatalog">Write operations</UseCaseGroup>
      </Analysis>
      <Rationale>
        All operations share SearchRepository and are cohesive around the search bounded context.
        Query and Index operations are complementary, not independent responsibilities.
        Future consideration: extract SearchIndexManagementService if complexity grows.
      </Rationale>
      <FutureConsideration>
        If reindexCatalog grows more complex or index management gets additional operations,
        consider extracting SearchIndexManagementService.
      </FutureConsideration>
    </Decision>

    <Decision id="DEC-CONFIG-PROPERTIES-PATTERN" status="APPROVED">
      <Title>Configuration Properties Pattern</Title>
      <Context>
        Spring Boot 4.0 recommends immutable configuration properties using records.
        Legacy mutable JavaBean pattern has thread-safety concerns and verbose boilerplate.
      </Context>
      <Selected>Immutable record pattern with @ConfigurationProperties and @Validated</Selected>
      <Pattern>
        <Item>Use Java records instead of mutable classes</Item>
        <Item>Annotate with @ConfigurationProperties(prefix = "kanokna.{service-name}")</Item>
        <Item>Annotate with @Validated for Bean Validation support</Item>
        <Item>Use nested records for hierarchical configuration</Item>
        <Item>Provide defaults via compact constructor with null-coalescing</Item>
        <Item>Apply Bean Validation annotations (@NotNull, @Positive, etc.) where applicable</Item>
      </Pattern>
      <PrefixConvention>
        <Item>cart-service: kanokna.cart</Item>
        <Item>account-service: kanokna.account</Item>
        <Item>search-service: kanokna.search</Item>
        <Item>pricing-service: kanokna.pricing</Item>
        <Item>catalog-configuration-service: kanokna.catalog</Item>
      </PrefixConvention>
      <Example>
        <![CDATA[
@Validated
@ConfigurationProperties(prefix = "kanokna.example")
public record ExampleProperties(
    @NotNull Timeouts timeouts,
    @NotNull Limits limits
) {
    public ExampleProperties {
        timeouts = timeouts != null ? timeouts : new Timeouts(Duration.ofSeconds(5));
        limits = limits != null ? limits : new Limits(100);
    }
    public record Timeouts(@NotNull Duration requestTimeout) {}
    public record Limits(@Positive int maxItems) {}
}
        ]]>
      </Example>
      <Benefits>
        <Item>Immutability: Thread-safe configuration access</Item>
        <Item>Type safety: Compiler-enforced property types</Item>
        <Item>Validation: Bean Validation integration with @Validated</Item>
        <Item>Conciseness: Records eliminate getter/setter boilerplate</Item>
        <Item>Spring Boot 4.0+: Recommended pattern per framework guidelines</Item>
      </Benefits>
      <PromotedFrom handoff="Handoff-20260117-04-W1-CONFIG-PATTERN" />
    </Decision>

    <!-- ═══════════════════════════════════════════════════════════════════════════
         TESTING DECISIONS (AWO-20260120-01)
         ═══════════════════════════════════════════════════════════════════════════ -->
    <Decision id="DEC-TEST-UNIT" status="APPROVED">
      <Title>Unit Testing Strategy</Title>
      <Context>Define tools and patterns for domain and application layer isolation testing</Context>
      <Selected>JUnit 5 + Mockito + AssertJ</Selected>
      <Scope>
        <Layer name="domain">Pure unit tests, no mocking (domain is mostly logic)</Layer>
        <Layer name="application">Unit tests with mocked driven ports (repositories, external services)</Layer>
      </Scope>
      <NamingConvention>*Test.java (run by maven-surefire-plugin)</NamingConvention>
      <Rationale>
        Industry standard stack with excellent Spring integration.
        AssertJ provides fluent, readable assertions.
        Mockito for port isolation without heavy framework dependencies.
      </Rationale>
      <Links>
        <Link ref="Technology.xml#TECH-junit5" />
        <Link ref="Technology.xml#TECH-mockito" />
        <Link ref="Technology.xml#TECH-assertj" />
        <Link ref="DevelopmentPlan.xml#TestingStrategy" />
      </Links>
    </Decision>

    <Decision id="DEC-TEST-GRPC-INTEGRATION" status="APPROVED">
      <Title>gRPC Integration Testing</Title>
      <Context>Define tools for testing inter-service gRPC communication</Context>
      <Selected>SpringBootTest + @GrpcClientTest + grpc-inprocess</Selected>
      <Tools>
        <Tool>Spring gRPC Test (1.0.x) for @GrpcClientTest annotation</Tool>
        <Tool>grpc-testing for in-process server/client tests</Tool>
        <Tool>GrpcMock for mocking external gRPC services</Tool>
      </Tools>
      <Scope>
        <Item>Client-side tests: Verify gRPC client adapters correctly call remote services</Item>
        <Item>Server-side tests: Verify gRPC server adapters correctly expose service contracts</Item>
        <Item>Contract alignment: Ensure Protobuf contracts match implementation</Item>
      </Scope>
      <NamingConvention>*GrpcIntegrationTest.java (run by maven-failsafe-plugin)</NamingConvention>
      <Rationale>
        Spring gRPC Test provides seamless integration with Spring Boot test slices.
        In-process testing avoids network overhead and port conflicts.
      </Rationale>
      <Links>
        <Link ref="Technology.xml#TECH-spring-grpc-test" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-api-contracts" />
      </Links>
    </Decision>

    <Decision id="DEC-TEST-GATEWAY" status="APPROVED">
      <Title>Gateway/REST Testing</Title>
      <Context>Define tools for testing Spring Cloud Gateway routing and REST endpoints</Context>
      <Selected>MockMvc + WebTestClient</Selected>
      <Tools>
        <Tool>MockMvc for synchronous @WebMvcTest sliced tests</Tool>
        <Tool>WebTestClient for reactive/gateway tests</Tool>
      </Tools>
      <Scope>
        <Item>Gateway routing: Verify path-based and header-based routing rules</Item>
        <Item>Authentication/Authorization: Verify JWT validation and role-based access</Item>
        <Item>REST endpoints: Verify request/response serialization and validation</Item>
      </Scope>
      <NamingConvention>*ControllerTest.java or *RestIntegrationTest.java</NamingConvention>
      <Rationale>
        MockMvc provides fast, focused tests without full server startup.
        WebTestClient required for reactive/non-blocking gateway tests.
      </Rationale>
      <Links>
        <Link ref="Technology.xml#TECH-spring-web-test" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-gateway" />
      </Links>
    </Decision>

    <Decision id="DEC-TEST-E2E" status="APPROVED">
      <Title>End-to-End Testing</Title>
      <Context>Define tools for full-stack cross-service flow testing</Context>
      <Selected>Testcontainers (full stack) + grpcurl (CLI verification)</Selected>
      <Location>Dedicated e2e-tests module at project root</Location>
      <Tools>
        <Tool>Testcontainers for PostgreSQL, Kafka, Redis, Elasticsearch</Tool>
        <Tool>Docker Compose integration for multi-service startup</Tool>
        <Tool>grpcurl for CLI-based smoke tests and manual verification</Tool>
      </Tools>
      <Scope>
        <Item>Cross-service flows: CPQ flow, order lifecycle, measurement workflow</Item>
        <Item>Event propagation: Verify Kafka events flow between services</Item>
        <Item>Data consistency: Verify eventual consistency across bounded contexts</Item>
      </Scope>
      <NamingConvention>*E2ETest.java (run by maven-failsafe-plugin with -Pe2e profile)</NamingConvention>
      <Rationale>
        Dedicated module avoids coupling E2E tests to individual service builds.
        Testcontainers ensures reproducible infrastructure.
        grpcurl enables manual verification and debugging.
      </Rationale>
      <Links>
        <Link ref="Technology.xml#TECH-testcontainers" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-e2e-tests" />
      </Links>
    </Decision>

    <Decision id="DEC-TEST-CONTRACTS" status="APPROVED">
      <Title>Contract Testing Framework</Title>
      <Context>Choose between Spring Cloud Contract and Pact for producer/consumer contract validation</Context>
      <Selected>Spring Cloud Contract</Selected>
      <Alternatives>
        <Alternative status="REJECTED" reason="Java-only ecosystem, better Spring integration available">
          Pact - language-agnostic, Pact Broker for central repository
        </Alternative>
      </Alternatives>
      <Workflow>
        <Step order="1">Define Groovy DSL contracts in api-contracts/src/test/resources/contracts/</Step>
        <Step order="2">Producer service runs generated verifier tests from contracts</Step>
        <Step order="3">Stubs auto-generated and published to Maven repository</Step>
        <Step order="4">Consumer services use @AutoConfigureStubRunner for stub-based testing</Step>
      </Workflow>
      <NamingConvention>*ContractTest.java (run by maven-failsafe-plugin)</NamingConvention>
      <Rationale>
        Spring Cloud Contract provides seamless Spring ecosystem integration.
        Groovy DSL contracts are expressive and version-controlled with api-contracts module.
        Auto-generated stubs eliminate manual mock maintenance.
        Maven plugin integration fits existing build pipeline.
      </Rationale>
      <Links>
        <Link ref="Technology.xml#TECH-spring-cloud-contract" />
        <Link ref="DevelopmentPlan.xml#DP-SVC-api-contracts" />
        <Link ref="DevelopmentPlan.xml#ContractEvolutionPolicy" />
      </Links>
    </Decision>

    <Decision id="DEC-TEST-COVERAGE" status="APPROVED">
      <Title>Code Coverage Thresholds</Title>
      <Context>Define minimum coverage requirements enforced by CI</Context>
      <Selected>80% line coverage, 70% branch coverage</Selected>
      <Tool>JaCoCo (0.8.x via Maven plugin)</Tool>
      <Enforcement>
        <Item>CI build fails if coverage falls below thresholds</Item>
        <Item>Aggregate report across all modules</Item>
        <Item>Exclude generated code: Protobuf, MapStruct mappers</Item>
        <Item>Exclude trivial code: adapters.*.mapper packages from branch coverage</Item>
      </Enforcement>
      <Rationale>
        80%/70% is industry standard, achievable without test bloat.
        Enforces discipline without blocking legitimate work.
        Exclusions prevent penalizing generated/trivial code.
      </Rationale>
      <Links>
        <Link ref="Technology.xml#TECH-jacoco" />
      </Links>
    </Decision>

    <Decision id="DEC-TEST-SHARED-UTILS" status="APPROVED">
      <Title>Shared Test Utilities Location</Title>
      <Context>Decide whether test utilities are centralized or per-service</Context>
      <Selected>Dedicated test-support module (shared/test-support)</Selected>
      <Alternatives>
        <Alternative status="REJECTED" reason="Causes duplication of Testcontainers configs">
          Per-service test fixtures in src/test/java/.../support/
        </Alternative>
      </Alternatives>
      <Contents>
        <Item>Shared Testcontainers configurations (PostgresTestContainer, KafkaTestContainer, etc.)</Item>
        <Item>Common test fixtures and test data builders</Item>
        <Item>Shared ArchUnit rule library (HexagonalArchitectureRules.java)</Item>
        <Item>Custom AssertJ assertions for shared-kernel domain objects</Item>
        <Item>gRPC test utilities and mock server helpers</Item>
      </Contents>
      <PackageLayout>
        <Package>com.kanokna.test.containers</Package>
        <Package>com.kanokna.test.fixtures</Package>
        <Package>com.kanokna.test.archunit</Package>
        <Package>com.kanokna.test.assertions</Package>
        <Package>com.kanokna.test.grpc</Package>
      </PackageLayout>
      <Rationale>
        Centralized module avoids duplication of Testcontainers startup logic.
        Services depend on test-support with scope=test.
        Consistent ArchUnit rules enforced across all services.
      </Rationale>
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-test-support" />
      </Links>
    </Decision>

    <!-- ═══════════════════════════════════════════════════════════════════════════
         SECURITY DECISIONS (AWO-20260121-01)
         ═══════════════════════════════════════════════════════════════════════════ -->
    <Decision id="DEC-SEC-CSRF-STATELESS" status="APPROVED">
      <Title>CSRF Protection Disabled for Stateless JWT APIs</Title>
      <Context>
        GitHub CodeQL flags Spring Security configurations that disable CSRF protection
        (java/spring-disabled-csrf-protection - HIGH severity). All 8 services in this
        project intentionally disable CSRF via .csrf(csrf -> csrf.disable()).
      </Context>
      <Selected>CSRF protection intentionally disabled - documented architectural decision</Selected>
      <Justification>
        <Item>All APIs are stateless REST endpoints using JWT bearer token authentication</Item>
        <Item>No browser-based form submissions or cookie-based sessions are used</Item>
        <Item>JWT tokens are transmitted via Authorization header, not cookies</Item>
        <Item>Internal gRPC services do not use browser contexts</Item>
        <Item>API Gateway validates JWT tokens before routing to backend services</Item>
        <Item>CSRF attacks require cookie-based authentication which is not present</Item>
      </Justification>
      <References>
        <Reference>OWASP CSRF Prevention Cheat Sheet - "Stateless (sessionless) applications don't need CSRF protection"</Reference>
        <Reference>Spring Security Documentation - "CSRF protection should be used for any request that could be processed by a browser"</Reference>
      </References>
      <AffectedServices>
        <Service name="config-server">SecurityConfig.java - infrastructure service</Service>
        <Service name="gateway">SecurityConfig.java - JWT validation at edge</Service>
        <Service name="pricing-service">SecurityConfig.java - stateless API</Service>
        <Service name="account-service">SecurityConfig.java - stateless API</Service>
        <Service name="cart-service">SecurityConfig.java - stateless API</Service>
        <Service name="catalog-configuration-service">SecurityConfig.java - stateless API</Service>
        <Service name="search-service">SecurityConfig.java - stateless API</Service>
      </AffectedServices>
      <CodeQLSuppression>
        <Method>Suppress via .github/codeql-config.yml query-filters</Method>
        <AddComments>Add explanatory comments in SecurityConfig.java files</AddComments>
      </CodeQLSuppression>
      <Links>
        <Link ref="RequirementsAnalysis.xml#NFR-SEC-AUTHENTICATION" />
        <Link ref="Technology.xml#TECH-spring-security" />
        <Link ref="DEC-SEC-CODEQL-EXCLUSIONS" />
      </Links>
    </Decision>

    <Decision id="DEC-SEC-LOG-SANITIZATION" status="APPROVED">
      <Title>Log Injection Prevention Strategy</Title>
      <Context>
        GitHub CodeQL flagged log injection vulnerabilities (java/log-injection - HIGH severity)
        in pricing-service where user-provided data (productTemplateId, promoCode) is logged
        without sanitization. Malicious input could inject newlines or ANSI escape sequences.
      </Context>
      <Selected>OWASP Java Encoder library with LogSanitizer utility in shared-kernel</Selected>
      <Alternatives>
        <Alternative status="REJECTED" reason="Requires maintenance, easy to miss edge cases">
          Custom sanitizer in shared-kernel replacing newlines/CR/tabs/ANSI
        </Alternative>
        <Alternative status="REJECTED" reason="SLF4J does not prevent log injection">
          SLF4J parameterized logging only
        </Alternative>
        <Alternative status="REJECTED" reason="Requires logging infrastructure changes">
          MDC-based structured logging
        </Alternative>
      </Alternatives>
      <Implementation>
        <Dependency>
          <GroupId>org.owasp.encoder</GroupId>
          <ArtifactId>encoder</ArtifactId>
          <Version>1.2.3</Version>
          <Scope>compile</Scope>
          <AddTo>shared-kernel</AddTo>
        </Dependency>
        <UtilityClass>
          <Name>LogSanitizer</Name>
          <Package>com.kanokna.shared.logging</Package>
          <Methods>
            <Method name="sanitize(String input)">Returns sanitized string safe for logging</Method>
            <Method name="sanitizeMap(Map input)">Sanitizes all string values in a map</Method>
          </Methods>
        </UtilityClass>
        <UsagePattern>
          <Example>logger.info("Processing product template: {}", LogSanitizer.sanitize(productTemplateId));</Example>
          <Example>logger.debug("Applying promo code: {}", LogSanitizer.sanitize(promoCode));</Example>
        </UsagePattern>
      </Implementation>
      <AffectedFiles>
        <File path="services/pricing-service/.../PriceCalculationUseCaseService.java" lines="110,203" />
      </AffectedFiles>
      <Rationale>
        OWASP Encoder is the industry standard for output encoding. It handles edge cases
        comprehensively (newlines, carriage returns, tabs, ANSI escapes, Unicode control chars).
        Centralizing in shared-kernel ensures consistent usage across all services.
      </Rationale>
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-shared-kernel" />
        <Link ref="RequirementsAnalysis.xml#NFR-SEC-VULNERABILITY-SCAN" />
      </Links>
    </Decision>

    <Decision id="DEC-SEC-CODEQL-EXCLUSIONS" status="APPROVED">
      <Title>CodeQL Configuration for Generated Code Exclusions</Title>
      <Context>
        CodeQL reports 1000+ alerts for missing @Override annotations in Protobuf-generated
        code under api-contracts/target/generated-sources/. These are false positives for
        generated code that should not be manually modified.
      </Context>
      <Selected>Custom CodeQL configuration with paths-ignore and query-filters</Selected>
      <Configuration>
        <File path=".github/codeql-config.yml">
          <Content><![CDATA[
name: "Kanokna CodeQL Config"

# Exclude generated sources from analysis
paths-ignore:
  - '**/target/generated-sources/**'
  - '**/target/generated-test-sources/**'
  - '**/generated/**'
  - '**/*Proto.java'
  - '**/*Grpc.java'

# Suppress specific rules with documented justification
query-filters:
  - exclude:
      id: java/spring-disabled-csrf-protection
      # Justification: DEC-SEC-CSRF-STATELESS - stateless JWT APIs
          ]]></Content>
        </File>
        <WorkflowUpdate path=".github/workflows/codeql.yml">
          <Change>Add config-file reference to analyze step</Change>
          <Example><![CDATA[
- name: Initialize CodeQL
  uses: github/codeql-action/init@v3
  with:
    languages: java
    config-file: ./.github/codeql-config.yml
          ]]></Example>
        </WorkflowUpdate>
      </Configuration>
      <ExcludedPaths>
        <Path pattern="**/target/generated-sources/**">Protobuf generated code</Path>
        <Path pattern="**/target/generated-test-sources/**">Test generated code</Path>
        <Path pattern="**/*Proto.java">Protobuf message classes</Path>
        <Path pattern="**/*Grpc.java">gRPC service stubs</Path>
      </ExcludedPaths>
      <SuppressedRules>
        <Rule id="java/spring-disabled-csrf-protection" reason="DEC-SEC-CSRF-STATELESS" />
      </SuppressedRules>
      <Rationale>
        Generated code should not be analyzed - it cannot be modified and produces noise.
        Documented security decisions can be suppressed via query-filters with clear
        traceability to architectural decisions.
      </Rationale>
      <Links>
        <Link ref="DevelopmentPlan.xml#DP-SVC-api-contracts" />
        <Link ref="DEC-SEC-CSRF-STATELESS" />
      </Links>
    </Decision>
  </Decisions>

  <!-- ═══════════════════════════════════════════════════════════════════════════
       ASSUMPTIONS
       ═══════════════════════════════════════════════════════════════════════════ -->
  <Assumptions>
    <Assumption id="TECH-ASSUM-001">
      Spring Boot 4.0.0 version in POM is a placeholder; actual APIs may differ from current 3.x.
      Implementation must verify compatibility when 4.x is released.
    </Assumption>
    <Assumption id="TECH-ASSUM-002">
      Object storage provider decision (MinIO vs S3) deferred to deployment configuration.
      API is S3-compatible in either case.
    </Assumption>
  </Assumptions>

</Technology>