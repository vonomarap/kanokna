<DevelopmentPlan version="1.0">
  <Service id="Service-reporting-service">
    <Description>Aggregates and serves dashboards/exports using event-driven data ingestion.</Description>
    <BoundedContext>reporting</BoundedContext>
    <Responsibilities>
      <Item>Ingest order/payment/installation/pricing events</Item>
      <Item>Compute aggregated views for dashboards</Item>
      <Item>Provide REST APIs for dashboards and exports</Item>
    </Responsibilities>
    <Dependencies>
      <ServiceRef ref="shared-kernel"/>
      <ServiceRef ref="order-service" type="async-events"/>
      <ServiceRef ref="pricing-service" type="async-events" optional="true"/>
      <ServiceRef ref="search-service" type="async-events" optional="true"/>
    </Dependencies>
    <Links>
      <Link ref="RequirementsAnalysis.xml#UC-REPORT-DASHBOARD"/>
      <Link ref="RequirementsAnalysis.xml#UC-REPORT-EXPORT"/>
      <Link ref="Technology.xml#Interfaces"/>
    </Links>
  </Service>

  <Architecture>
    <Layers>
      <Domain>com.kanokna.reporting_service.domain.* (pure Java)</Domain>
      <Application>com.kanokna.reporting_service.application.* (use cases, ports, DTOs)</Application>
      <AdaptersIn>com.kanokna.reporting_service.adapters.in.* (web, kafka listeners)</AdaptersIn>
      <AdaptersOut>com.kanokna.reporting_service.adapters.out.* (persistence, cache)</AdaptersOut>
    </Layers>
    <Enforcement>ArchUnit: domain free of Spring/JPA; application depends on domain and ports only.</Enforcement>
  </Architecture>

  <Ports>
    <Inbound>
      <Port name="DashboardPort" layer="application.port.in">
        <Operation>getSalesDashboard</Operation>
        <Operation>getConversionDashboard</Operation>
        <Operation>getProductPerformanceDashboard</Operation>
      </Port>
      <Port name="ExportPort" layer="application.port.in">
        <Operation>createExport</Operation>
        <Operation>getExportStatus</Operation>
      </Port>
      <Port name="IngestionPort" layer="application.port.in">
        <Operation>ingestEvent</Operation>
      </Port>
    </Inbound>
    <Outbound>
      <Port name="ReportRepository" layer="application.port.out"/>
      <Port name="ExportRepository" layer="application.port.out"/>
      <Port name="CachePort" layer="application.port.out"/>
    </Outbound>
  </Ports>

  <DomainModel>
    <Aggregate name="ReportAggregate">
      <Identifier>ReportId</Identifier>
      <State>type, dimensions, metrics, lastUpdated</State>
      <Events>
        <Event>ReportUpdated</Event>
      </Events>
    </Aggregate>
    <Aggregate name="ExportJob">
      <Identifier>ExportJobId</Identifier>
      <State>filters, status, location, createdAt, completedAt</State>
      <Events>
        <Event>ExportCreated</Event>
        <Event>ExportCompleted</Event>
      </Events>
    </Aggregate>
    <ValueObject name="IngestedEvent">type, payload</ValueObject>
  </DomainModel>

  <Contracts>
    <ModuleContract id="mod.reporting.ingestion" layer="application.service">
      <Purpose>Ingest domain events idempotently and update aggregates.</Purpose>
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-REPORT-DASHBOARD"/>
      </Links>
      <FunctionContracts>
        <FunctionContract id="ingestEvent" layer="application.service" intent="Process inbound events into aggregates">
          <Input>IngestedEvent</Input>
          <Output>IngestionResult</Output>
          <Preconditions>Event schema validated; idempotency key present</Preconditions>
          <Postconditions>Aggregates updated; ReportUpdated event emitted if needed</Postconditions>
          <BlockAnchors>
            <Block id="REPORT-INGEST-IDEMP" purpose="Check idempotency/key"/>
            <Block id="REPORT-INGEST-APPLY" purpose="Apply event to aggregates"/>
            <Block id="REPORT-INGEST-CACHE" purpose="Refresh cache if required"/>
          </BlockAnchors>
          <LoggingPattern>[REPORT][ingestEvent][block={id}][state={state}]</LoggingPattern>
        </FunctionContract>
      </FunctionContracts>
    </ModuleContract>
    <ModuleContract id="mod.reporting.query" layer="application.service">
      <Purpose>Query dashboards with cached aggregates.</Purpose>
      <Links>
        <Link ref="RequirementsAnalysis.xml#UC-REPORT-DASHBOARD"/>
      </Links>
      <FunctionContracts>
        <FunctionContract id="getDashboard" layer="application.service" intent="Return dashboard aggregates">
          <Input>DashboardQuery</Input>
          <Output>DashboardResult</Output>
          <Preconditions>Dashboard type recognized</Preconditions>
          <Postconditions>Aggregated metrics returned; cache used if warm</Postconditions>
          <BlockAnchors>
            <Block id="REPORT-QUERY-CACHE" purpose="Check cache for dashboard"/>
            <Block id="REPORT-QUERY-DB" purpose="Query read model if cache miss"/>
          </BlockAnchors>
          <LoggingPattern>[REPORT][getDashboard][block={id}][state={state}]</LoggingPattern>
        </FunctionContract>
      </FunctionContracts>
    </ModuleContract>
  </Contracts>

  <Flows>
    <Flow id="Flow-Ingestion">
      <Description>Consume events and update aggregates.</Description>
      <Sequence>
        <Step order="1" from="Kafka" to="Adapter (listener)">Receive event</Step>
        <Step order="2" from="Adapter" to="Application Service">ingestEvent</Step>
        <Step order="3" from="Application Service" to="Persistence/Cache">Update aggregates</Step>
      </Sequence>
    </Flow>
    <Flow id="Flow-Dashboard-Query">
      <Description>Return dashboard data.</Description>
      <Sequence>
        <Step order="1" from="Adapter (REST)" to="Application Service">Dashboard query</Step>
        <Step order="2" from="Application Service" to="CachePort">Check cache</Step>
        <Step order="3" from="Application Service" to="ReportRepository">Query if needed</Step>
        <Step order="4" from="Application Service" to="Adapter">Return result</Step>
      </Sequence>
    </Flow>
    <Flow id="Flow-Export">
      <Description>Create and serve exports.</Description>
      <Sequence>
        <Step order="1" from="Adapter (REST)" to="Application Service">createExport</Step>
        <Step order="2" from="Application Service" to="ExportRepository">Persist job</Step>
        <Step order="3" from="Application Service" to="Background Worker" optional="true">Generate export file</Step>
        <Step order="4" from="Application Service" to="Adapter">Return link/status</Step>
      </Sequence>
    </Flow>
  </Flows>

  <PersistencePlan>
    <Table name="report_aggregate">
      <Column name="id" type="UUID" role="PK"/>
      <Column name="type" type="VARCHAR(100)"/>
      <Column name="dimensions" type="JSONB"/>
      <Column name="metrics" type="JSONB"/>
      <Column name="last_updated" type="TIMESTAMP WITH TIME ZONE"/>
    </Table>
    <Table name="export_job">
      <Column name="id" type="UUID" role="PK"/>
      <Column name="filters" type="JSONB"/>
      <Column name="status" type="VARCHAR(20)"/>
      <Column name="location" type="VARCHAR(255)" nullable="true"/>
      <Column name="created_at" type="TIMESTAMP WITH TIME ZONE"/>
      <Column name="completed_at" type="TIMESTAMP WITH TIME ZONE" nullable="true"/>
    </Table>
  </PersistencePlan>

  <TestingStrategy>
    <Unit>Aggregation logic and idempotent ingestion</Unit>
    <Slice>@DataJpaTest for read models; @WebMvcTest for REST</Slice>
    <Integration>Testcontainers for PostgreSQL/Redis/Kafka</Integration>
    <ContractTests>OpenAPI for REST</ContractTests>
    <Architecture>ArchUnit enforcing hexagonal boundaries and shared-kernel purity</Architecture>
  </TestingStrategy>

  <Observability>
    <Metrics>Ingestion lag, query latency, export job duration</Metrics>
    <Tracing>Include reportId/exportId in spans</Tracing>
    <Logging>Structured JSON with block anchors (REPORT-INGEST-*, REPORT-QUERY-*, REPORT-EXPORT-*)</Logging>
  </Observability>

  <Deployment>
    <Packaging>Jib/Buildpacks OCI image</Packaging>
    <Config>Config-server profiles dev/stage/prod</Config>
    <Rollout>Rolling/blue-green; Flyway migrations expand-migrate-contract</Rollout>
    <Secrets>Vault/K8s Secrets; no secrets in code</Secrets>
  </Deployment>
</DevelopmentPlan>
