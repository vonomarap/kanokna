<Technology version="1.0">
  <Runtime>
    <Language>Java 25</Language>
    <Framework>Spring Boot 4.0.x (Web, Validation)</Framework>
    <Architecture>DDD + Hexagonal; domain/application free of Spring/JPA/transport dependencies.</Architecture>
  </Runtime>

  <Frameworks>
    <SpringDataJpa>3.3.x with Hibernate 6.x; ddl-auto=validate</SpringDataJpa>
    <SpringSecurity>OAuth2 Resource Server (JWT)</SpringSecurity>
    <Resilience4j>Timeouts, retries (expo+jitter), circuit breakers, bulkheads</Resilience4j>
    <MapStruct>1.5+ for mappers</MapStruct>
    <OpenAPI>springdoc-openapi 2.x for REST contracts</OpenAPI>
  </Frameworks>

  <Infrastructure>
    <Database>
      <Engine>PostgreSQL 16</Engine>
      <Migrations>Flyway</Migrations>
      <Rules>Disable Open-Session-in-View; equals/hashCode by business key; optimistic locking with @Version.</Rules>
    </Database>
    <Cache>
      <Engine>Redis 7.x</Engine>
      <Usage>Short-lived holds for checkout context and idempotency tokens.</Usage>
    </Cache>
    <Messaging>
      <Broker>Kafka 3.x</Broker>
      <OutboundTopics>
        <Topic name="order.created" key="orderId"/>
        <Topic name="order.confirmed" key="orderId"/>
        <Topic name="order.cancelled" key="orderId"/>
        <Topic name="order.installation-scheduled" key="orderId"/>
        <Topic name="payment.updated" key="paymentId" optional="true"/>
      </OutboundTopics>
      <InboundTopics>
        <Topic name="payment.callback" optional="true"/>
      </InboundTopics>
      <Pattern>Transactional outbox for outbound events; idempotent consumers for callbacks.</Pattern>
    </Messaging>
    <External>
      <Service>Payment gateway via webhook/callback</Service>
      <Service>Scheduling system (installer) optional integration</Service>
    </External>
  </Infrastructure>

  <Interfaces id="Interfaces">
    <REST base="/api/v1/orders">
      <Endpoint>POST /checkout (create order from cart)</Endpoint>
      <Endpoint>GET /{orderId}</Endpoint>
      <Endpoint>POST /{orderId}/payments (initiate payment)</Endpoint>
      <Endpoint>POST /payments/callback (webhook)</Endpoint>
      <Endpoint>POST /{orderId}/installation (schedule/update)</Endpoint>
    </REST>
    <gRPC enabled="optional" endpoint="/grpc/orders">
      <Method>CreateOrderFromCart(cartId)</Method>
      <Method>GetOrder(orderId)</Method>
    </gRPC>
  </Interfaces>

  <CrossCutting>
    <Security>
      <Auth>OAuth2/OIDC JWT; BUYER for customer orders; ADMIN/OPS for overrides; SERVICE for internal calls.</Auth>
      <Validation>Bean Validation on DTOs; domain invariants for states/payments.</Validation>
    </Security>
    <Observability>
      <Metrics>Micrometer + Prometheus; metrics: checkout latency, payment success rate, state transition counts.</Metrics>
      <Tracing>OpenTelemetry; include orderId, paymentId, cartId in spans.</Tracing>
      <Logging>Structured JSON with block anchors (ORDER-VALIDATE/PERSIST/EVENT, PAY-CALLBACK-*) for belief-state tracing.</Logging>
    </Observability>
    <Resilience>
      <Timeouts>Payment gateway interactions bounded</Timeouts>
      <Retries>Idempotent payment callback handling; circuit breakers for external calls.</Retries>
    </Resilience>
    <Testing>
      <Unit>Order state machine, payment handling, idempotency logic</Unit>
      <Slice>@DataJpaTest for repositories; @WebMvcTest for controllers</Slice>
      <Integration>Testcontainers for PostgreSQL/Redis/Kafka</Integration>
      <Contract>OpenAPI for REST; AsyncAPI/Avro for events</Contract>
      <Architecture>ArchUnit enforcing hexagonal boundaries and shared-kernel purity</Architecture>
    </Testing>
  </CrossCutting>

  <Links>
    <Link ref="RequirementsAnalysis.xml"/>
    <Link ref="DevelopmentPlan.xml"/>
  </Links>
</Technology>
